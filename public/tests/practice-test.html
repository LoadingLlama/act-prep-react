<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practice Test</title>
    <link rel="stylesheet" href="shared-test-styles.css">

    <style>
        /* Explanation content styling */
        .review-explanation {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.9375rem;
            line-height: 1.6;
            color: #000000;
            font-weight: 400;
        }

        /* Default: no bold for inline strong tags */
        .review-explanation strong {
            font-weight: 400;
            color: #000000;
        }

        /* "Why Other Answers Are Wrong:" header - make bold */
        .review-explanation > div > div:last-child > div > strong {
            font-size: 0.9375rem;
            font-weight: 600;
            color: #000000;
        }

        /* Individual wrong answer items */
        .review-explanation > div > div:last-child > div > div {
            font-size: 0.9375rem;
            line-height: 1.6;
            color: #000000;
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            position: relative;
            font-weight: 400;
        }

        /* Choice labels (Choice A:, Choice B:, etc.) - make bold */
        .review-explanation > div > div:last-child > div > div strong {
            font-weight: 600;
            color: #000000;
        }

        .review-explanation > div > div:last-child > div > div::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #000000;
            font-weight: 400;
        }

        .review-explanation > div > div:last-child > div > div:last-child {
            margin-bottom: 0;
        }
    </style>

    <!-- MathJax for math rendering -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <!-- Header outside container for full width -->
    <div class="test-header">
        <div class="header-content">
            <a href="/" class="logo">Nomi Academy</a>
            <div class="header-center"></div>
            <div class="header-right">
                <span class="question-counter">
                    <span class="question-counter-label">Answered</span>
                    <span class="question-counter-value" id="questionCounter">0 of 215</span>
                </span>
                <div class="timer-container">
                    <span class="timer-label">Total Time Left</span>
                    <div class="timer" id="timer">--:--</div>
                </div>
                <button class="end-section-link" onclick="confirmEndSection()">
                    <span>End</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                        <rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div class="test-container">
        <div class="test-main">
            <!-- Questions Navigation - Outside container -->
            <div class="questions-nav-external">
                <div class="sidebar-icon" onclick="showQuestionModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M9 2C8.44772 2 8 2.44772 8 3V4H6C4.89543 4 4 4.89543 4 6V20C4 21.1046 4.89543 22 6 22H18C19.1046 22 20 21.1046 20 20V6C20 4.89543 19.1046 4 18 4H16V3C16 2.44772 15.5523 2 15 2C14.4477 2 14 2.44772 14 3V4H10V3C10 2.44772 9.55228 2 9 2ZM6 8V20H18V8H6ZM8 11C8 10.4477 8.44772 10 9 10H15C15.5523 10 16 10.4477 16 11C16 11.5523 15.5523 12 15 12H9C8.44772 12 8 11.5523 8 11ZM9 14C8.44772 14 8 14.4477 8 15C8 15.5523 8.44772 16 9 16H15C15.5523 16 16 15.5523 16 15C16 14.4477 15.5523 14 15 14H9Z"/>
                    </svg>
                </div>
                <div class="sidebar-text">Questions</div>
            </div>

            <!-- Main Content -->
            <div class="test-content" id="testContent">
                <!-- Flag Bar -->
                <div class="flag-bar">
                    <span class="item-number" id="itemNumber">Item 1</span>
                    <button class="flag-button" id="flagBtn" onclick="toggleFlag()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                            <path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path>
                        </svg>
                        Flag
                    </button>
                </div>

                <!-- Hidden image upload section template -->
                <div id="imageUploadSection" style="display: none;">
                    <div class="image-upload-container">
                        <p>Need to show work? Upload an image of your scratch paper.</p>
                        <input type="file" accept="image/*" id="imageUpload" style="display: none;">
                        <button onclick="document.getElementById('imageUpload').click()">Upload Image</button>
                    </div>
                </div>

                <!-- Passages Section -->
                <div class="passage-section" id="passageSection">
                    <!-- Passage content will be injected here -->
                </div>

                <!-- Questions Section -->
                <div class="question-section" id="questionSection">
                    <!-- Question content will be injected here -->
                </div>

                <!-- Navigation inside content -->
                <div class="navigation">
                    <button class="nav-button" id="prevBtn" onclick="previousQuestion()" disabled>‚Äπ PREV</button>
                    <button class="nav-button primary" id="nextBtn" onclick="nextQuestion()">NEXT ‚Ä∫</button>
                </div>
            </div>

            <!-- Question Sidebar -->
            <div class="question-sidebar">
                <div class="sidebar-icon" onclick="toggleNavigator()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </div>
                <div class="sidebar-text" onclick="toggleNavigator()">Index</div>
                <div class="sidebar-divider"></div>
                <div class="sidebar-questions" id="sidebarQuestions"></div>
            </div>

            <!-- Sliding Question Navigator Panel -->
            <div class="question-navigator-panel" id="navigatorPanel">
                <div class="navigator-header">
                    <h3>Question Navigator</h3>
                    <button class="navigator-close" onclick="toggleNavigator()">‚úï</button>
                </div>
                <div class="navigator-content" id="navigatorContent">
                    <!-- Questions will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Question Navigator Modal -->
    <div class="modal" id="questionModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">Question Navigator</h3>
                <button class="close" onclick="closeQuestionModal()">√ó</button>
            </div>
            <div class="question-grid" id="questionGrid"></div>
            <div class="modal-footer">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color current"></div>
                        <span>Current</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color answered"></div>
                        <span>Answered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color flagged"></div>
                        <span>Flagged</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">End Section</h3>
                <button class="close" onclick="closeConfirmModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to end this section?</p>
                <p id="unansweredWarning" class="warning-text"></p>
                <div class="modal-actions">
                    <button class="nav-button" onclick="closeConfirmModal()">Cancel</button>
                    <button class="nav-button primary" onclick="endSection()">End Section</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Review mode state
        let reviewMode = false;
        let reviewModeData = null;

        // Load test data from sessionStorage
        let questions = JSON.parse(sessionStorage.getItem('practiceTestQuestions') || '[]');
        let section = sessionStorage.getItem('practiceTestSection') || 'english';
        const currentSection = section; // For image upload functionality
        let testNumber = sessionStorage.getItem('practiceTestNumber') || '1';
        let duration = parseInt(sessionStorage.getItem('practiceTestDuration') || '45');

        // Listen for review mode data from parent
        window.addEventListener('message', function(event) {
            if (event.data.type === 'LOAD_REVIEW_MODE') {
                console.log('üì® Received LOAD_REVIEW_MODE message:', event.data);
                reviewMode = true;
                reviewModeData = event.data;

                // Override test data with review data
                questions = event.data.questions;
                section = event.data.section;
                testNumber = '1'; // Diagnostic is always test 1
                duration = 0; // No timer in review mode

                console.log('‚úÖ Review mode enabled with', questions.length, 'questions');

                // Debug: Log first question structure to verify answers object
                if (questions.length > 0) {
                    const firstQ = questions[0];
                    console.log('üîç First question structure in iframe:', {
                        question_number: firstQ.question_number,
                        text: firstQ.text ? firstQ.text.substring(0, 50) : null,
                        has_answers: !!firstQ.answers,
                        answers_type: typeof firstQ.answers,
                        answers_keys: firstQ.answers ? Object.keys(firstQ.answers) : null,
                        answers_preview: firstQ.answers ? JSON.stringify(firstQ.answers).substring(0, 100) : null,
                        correctAnswer: firstQ.correctAnswer,
                        hasExplanation: !!firstQ.explanation,
                        allKeys: Object.keys(firstQ)
                    });
                }

                // Initialize test with review data
                initTest();
            } else if (event.data.type === 'LOAD_NEXT_SECTION') {
                console.log('üì® Received LOAD_NEXT_SECTION message - reloading from sessionStorage');
                console.log('   Current state before reload:', {
                    section: section,
                    questionCount: questions.length,
                    answersCount: Object.keys(answers).length
                });

                // Reload questions and section from sessionStorage (updated by parent)
                const newQuestions = JSON.parse(sessionStorage.getItem('practiceTestQuestions') || '[]');
                const newSection = sessionStorage.getItem('practiceTestSection') || 'english';
                const newDuration = parseInt(sessionStorage.getItem('practiceTestDuration') || '45');

                console.log('   SessionStorage contains:', {
                    section: newSection,
                    questionCount: newQuestions.length,
                    duration: newDuration,
                    firstQuestionNum: newQuestions[0]?.question_number,
                    lastQuestionNum: newQuestions[newQuestions.length - 1]?.question_number
                });

                questions = newQuestions;
                section = newSection;
                duration = newDuration;

                console.log('‚úÖ Loaded next section:', {
                    section: section,
                    questionCount: questions.length,
                    duration: duration
                });

                // Reset test state for new section
                answers = {};  // Clear answers from previous section
                hasPassages = questions.some(q => q.passage);
                totalQuestions = questions.length;
                currentQuestion = questions.length > 0 ? (questions[0].question_number || 1) : 1;
                timeLeft = duration * 60;

                // Add/remove math-test class based on passages
                if (!hasPassages) {
                    document.body.classList.add('math-test');
                } else {
                    document.body.classList.remove('math-test');
                }

                // Re-render the test with new questions
                renderContent();
                updateDisplay();
                generateSidebarQuestions();
                startTimer();

                console.log('‚úÖ New section initialized and ready');
            }
        });

        // Notify parent that iframe is ready
        window.addEventListener('load', function() {
            window.parent.postMessage({ type: 'IFRAME_READY' }, '*');
        });

        // Debug logging
        console.log('Practice Test Debug:', {
            section: section,
            sectionType: typeof section,
            testNumber: testNumber,
            questionsLoaded: questions.length,
            duration: duration,
            durationFromStorage: sessionStorage.getItem('practiceTestDuration'),
            timeLeft: duration * 60,
            firstQuestion: questions[0],
            rawQuestionsFromStorage: sessionStorage.getItem('practiceTestQuestions'),
            allSessionStorage: {
                questions: sessionStorage.getItem('practiceTestQuestions'),
                section: sessionStorage.getItem('practiceTestSection'),
                testNumber: sessionStorage.getItem('practiceTestNumber'),
                duration: sessionStorage.getItem('practiceTestDuration')
            }
        });

        // State - will be recalculated in initTest for review mode
        let hasPassages = false;
        let totalQuestions = 0;
        let currentQuestion = 1;
        let answers = {};
        let flaggedQuestions = new Set();
        let timeLeft = duration * 60; // Convert to seconds

        // If no questions on initial load and not waiting for review mode, show error
        if (questions.length === 0 && !sessionStorage.getItem('waitingForReviewMode')) {
            console.error('‚ùå NO QUESTIONS LOADED');
            console.error('SessionStorage keys:', Object.keys(sessionStorage));
            console.error('SessionStorage practiceTestQuestions:', sessionStorage.getItem('practiceTestQuestions'));

            document.getElementById('questionSection').innerHTML = `
                <div style="padding: 3rem; text-align: center;">
                    <h2 style="color: #dc2626; margin-bottom: 1rem;">‚ö†Ô∏è No Questions Loaded</h2>
                    <p style="color: #6b7280; margin-bottom: 1rem;">The test data was not loaded properly.</p>
                    <button onclick="window.parent.postMessage({type: 'PRACTICE_TEST_COMPLETE'}, '*')"
                            style="background: #4299e1; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-size: 1rem;">
                        Back to Tests
                    </button>
                </div>
            `;
        }

        // Initialize test
        function initTest() {
            console.log('üöÄ initTest called, questions.length:', questions.length);

            if (questions.length === 0) {
                console.log('‚ùå No questions found - timer will NOT start');
                document.getElementById('questionSection').innerHTML =
                    '<div style="padding: 2rem; text-align: center; color: #6b7280;">No questions loaded. Please go back and select a test.</div>';
                return;
            }

            console.log('‚úÖ Questions loaded, initializing test...');

            // Recalculate these values based on current questions array
            hasPassages = questions.some(q => q.passage);
            totalQuestions = questions.length;
            currentQuestion = questions.length > 0 ? (questions[0].question_number || 1) : 1;
            timeLeft = duration * 60;

            console.log('üìä Test configuration:', {
                hasPassages,
                totalQuestions,
                currentQuestion,
                section
            });

            // If in review mode, pre-fill answers
            if (reviewMode && reviewModeData) {
                console.log('üìù Pre-filling answers from review data');
                answers = { ...reviewModeData.userAnswers };
                console.log('‚úÖ Pre-filled answers:', answers);

                // Update timer text for review mode
                const timerEl = document.getElementById('timer');
                const timerLabel = document.querySelector('.timer-label');
                if (timerEl && timerLabel) {
                    timerLabel.textContent = 'Review Mode';
                    timerEl.textContent = '--:--';
                }

                // Update header for review mode
                const endButton = document.querySelector('.end-section-link span');
                if (endButton) {
                    endButton.textContent = 'Close';
                }
            }

            // Add math-test class if no passages
            if (!hasPassages) {
                document.body.classList.add('math-test');
            }

            // Render questions and passages
            renderContent();
            updateDisplay();
            generateSidebarQuestions();

            // Only start timer if not in review mode
            if (!reviewMode) {
                startTimer();
            } else {
                // Auto-open navigator in review mode
                setTimeout(() => {
                    const panel = document.getElementById('navigatorPanel');
                    const testMain = document.querySelector('.test-main');
                    const sidebar = document.querySelector('.question-sidebar');
                    if (panel && !panel.classList.contains('open')) {
                        panel.classList.add('open');
                        if (testMain) testMain.classList.add('navigator-open');
                        if (sidebar) sidebar.classList.add('navigator-open');
                        populateNavigator();
                    }
                }, 500);
            }
        }

        function renderContent() {
            console.log('üé® renderContent called, reviewMode:', reviewMode, 'hasReviewData:', !!reviewModeData);

            const passageSection = document.getElementById('passageSection');
            const questionSection = document.getElementById('questionSection');

            // Render passages if they exist
            if (hasPassages) {
                // Group questions by passage
                const passageGroups = {};
                questions.forEach((q, idx) => {
                    if (q.passage) {
                        if (!passageGroups[q.passage]) {
                            passageGroups[q.passage] = [];
                        }
                        passageGroups[q.passage].push(idx + 1);
                    }
                });

                let passageHTML = '';
                let passageNum = 1;

                // Sort passages by passage_number to maintain correct order
                const sortedPassages = Object.entries(passageGroups).sort((a, b) => {
                    const firstQuestionA = questions[a[1][0] - 1];
                    const firstQuestionB = questions[b[1][0] - 1];
                    const passageNumA = firstQuestionA.passage_number || Math.min(...a[1]);
                    const passageNumB = firstQuestionB.passage_number || Math.min(...b[1]);
                    return passageNumA - passageNumB;
                });

                sortedPassages.forEach(([passageKey, questionNums]) => {
                    // Get the first question in this passage group to access passage data
                    const firstQuestionIndex = questionNums[0] - 1;
                    const firstQuestion = questions[firstQuestionIndex];

                    // Get passage title and text
                    const passageTitle = firstQuestion.passage_title || '';
                    let passageContent = passageKey; // passageKey is the passage text

                    // Replace image placeholders with actual URLs
                    if (firstQuestion.passage_image_urls) {
                        passageContent = replaceImagePlaceholders(passageContent, firstQuestion.passage_image_urls);
                    }

                    // Normalize line breaks: handle \r\n\r\n (Windows) and \n\n (Unix)
                    const normalizedContent = passageContent.replace(/\r\n/g, '\n');
                    const paragraphs = normalizedContent.split('\n\n').filter(p => p.trim().length > 0);

                    // Only show title if it's meaningful (not generic like "English Passage 2")
                    const isGenericTitle = /^(English|Reading|Science|Math)\s+(Passage\s+)?\d+$/i.test(passageTitle);
                    const shouldShowTitle = passageTitle && !isGenericTitle;

                    passageHTML += `
                        <div class="passage-content" id="passage${passageNum}" data-questions="${questionNums.join(',')}">
                            ${shouldShowTitle ? `<h3 class="passage-title">${passageTitle}</h3>` : ''}
                            <div class="passage-text">
                                ${paragraphs.map(p => `<p>${p.trim()}</p>`).join('')}
                            </div>
                        </div>
                    `;
                    passageNum++;
                });

                // For Math/Science, prepend upload section to passage HTML
                if (section === 'math' || section === 'science') {
                    const uploadSectionHTML = document.getElementById('imageUploadSection').outerHTML;
                    passageSection.innerHTML = uploadSectionHTML + passageHTML;
                } else {
                    passageSection.innerHTML = passageHTML;
                }
            } else {
                // No passages - show upload section for Math/Science, hide for others
                if (section === 'math' || section === 'science') {
                    passageSection.style.display = 'flex';
                    const uploadSectionHTML = document.getElementById('imageUploadSection').outerHTML;
                    passageSection.innerHTML = uploadSectionHTML;
                } else {
                    passageSection.style.display = 'none';
                }
            }

            // Helper function to replace image placeholders with actual image tags
            function replaceImagePlaceholders(text, imageUrls) {
                if (!text || !imageUrls) return text;

                // Replace {{key}} placeholders with actual <img> tags
                let result = text;
                Object.keys(imageUrls).forEach(key => {
                    const placeholder = `{{${key}}}`;
                    const url = imageUrls[key];
                    const imgTag = `<img src="${url}" alt="Figure or Table" class="passage-image" />`;
                    result = result.replace(new RegExp(placeholder, 'g'), imgTag);
                });

                return result;
            }

            // Helper function to extract rhetorical question prompt
            function extractQuestionPrompt(text) {
                if (!text) return '';
                // Extract text inside brackets [...]
                const match = text.match(/\[([^\]]+)\]/);
                return match ? match[1] : text; // Return bracketed text if exists, otherwise full text
            }

            // Render questions
            console.log('üìù Starting question rendering. reviewMode:', reviewMode, 'questions:', questions.length);

            let questionHTML = '';
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1); // Use database question_number

                // CRITICAL: Ensure answers object exists
                // If answers is empty/null, the answer choices won't render!
                if (!q.answers || Object.keys(q.answers).length === 0) {
                    console.error(`‚ùå Question ${questionNum} has NO answers object! Cannot display choices.`, q);
                }

                const answerKeys = Object.keys(q.answers || {}).sort();
                let questionPrompt = extractQuestionPrompt(q.text);

                // Replace image placeholders in question text (for Math/Science)
                if (q.image_url && questionPrompt) {
                    questionPrompt = replaceImagePlaceholders(questionPrompt, q.image_url);
                }

                // Debug: Log answers object for first few questions
                if (idx < 3) {
                    console.log(`üîç Question ${questionNum} answers object:`, {
                        has_answers: !!q.answers,
                        answers_type: typeof q.answers,
                        answers_keys: answerKeys,
                        answers_content: q.answers,
                        correctAnswer: q.correctAnswer,
                        correctAnswer_type: typeof q.correctAnswer
                    });
                }

                // In review mode, get user's answer and correctness
                const userAnswerKey = `q${questionNum}`;
                const userAnswer = reviewMode && reviewModeData ? reviewModeData.userAnswers[userAnswerKey] : null;
                const isCorrect = reviewMode && reviewModeData ? reviewModeData.correctnessMap[userAnswerKey] : null;
                const correctAnswer = q.correctAnswer;

                if (idx === 0) {
                    console.log('üîç First question render debug:', {
                        reviewMode,
                        hasReviewData: !!reviewModeData,
                        questionNum,
                        userAnswerKey,
                        userAnswer,
                        isCorrect,
                        correctAnswer,
                        hasExplanation: !!q.explanation,
                        explanation: q.explanation ? q.explanation.substring(0, 50) : null,
                        reviewModeData: reviewModeData ? Object.keys(reviewModeData) : null
                    });
                }

                if (idx === 0 && reviewMode) {
                    console.log('üîç ReviewModeData structure:', {
                        userAnswersKeys: reviewModeData ? Object.keys(reviewModeData.userAnswers || {}).slice(0, 5) : null,
                        correctnessMapKeys: reviewModeData ? Object.keys(reviewModeData.correctnessMap || {}).slice(0, 5) : null
                    });
                }

                // For English questions with passages, extract the underlined portion as context
                let underlinedContext = '';
                if (q.passage && q.passage.includes('<u>')) {
                    // Find the nth underlined portion (where n is the index of this question in the passage)
                    const underlinedPortions = q.passage.match(/<u>[^<]+<\/u>/g) || [];
                    const questionsWithSamePassage = questions.filter(x => x.passage === q.passage);
                    const indexInPassage = questionsWithSamePassage.findIndex(x => x.question_number === questionNum);

                    if (underlinedPortions[indexInPassage]) {
                        const underlinedText = underlinedPortions[indexInPassage].replace(/<\/?u>/g, '');
                        underlinedContext = `<div class="underlined-context" style="padding: 0.75rem 1rem; background: #fef9c3; border-left: 3px solid #fbbf24; border-radius: 4px; margin-bottom: 1rem; font-family: 'Georgia', serif; line-height: 1.6;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: #92400e; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.375rem;">Underlined Portion:</div>
                            <div style="font-size: 0.9375rem; color: #78350f;">"${underlinedText}"</div>
                        </div>`;
                    }
                }

                questionHTML += `
                    <div class="question" id="question${questionNum}" data-passage="${hasPassages ? (questions.findIndex(x => x.passage === q.passage) + 1) : ''}">
                        ${underlinedContext}
                        ${questionPrompt ? `<div class="question-text">${questionPrompt}</div>` : ''}
                        ${q.image_url ? `<div class="question-image"><img src="${q.image_url}" alt="Question ${questionNum} diagram" /></div>` : ''}
                        <div class="answer-choices">
                            ${answerKeys.map(key => {
                                const isUserAnswer = reviewMode && userAnswer === key;
                                const isCorrectAnswer = reviewMode && correctAnswer === key;
                                let choiceClass = 'answer-choice';
                                let inlineStyle = '';

                                if (reviewMode) {
                                    if (isCorrectAnswer) {
                                        choiceClass += ' correct-answer';
                                        inlineStyle = 'background: #d1fae5 !important; border-left: 3px solid #10b981; padding-left: 0.5rem;';
                                    }
                                    if (isUserAnswer && !isCorrect) {
                                        choiceClass += ' wrong-answer';
                                        inlineStyle = 'background: #fee2e2 !important; border-left: 3px solid #ef4444; padding-left: 0.5rem;';
                                    }
                                    if (isUserAnswer && isCorrect) {
                                        choiceClass += ' user-answer';
                                        inlineStyle = 'background: #d1fae5 !important; border-left: 3px solid #10b981; padding-left: 0.5rem;';
                                    }
                                }

                                                // Debug first question's first answer choice
                                if (idx === 0 && key === answerKeys[0]) {
                                    console.log('üé® First question answer styling:', {
                                        questionNum,
                                        answerKeys,
                                        testingKey: key,
                                        correctAnswer,
                                        correctAnswerType: typeof correctAnswer,
                                        isCorrectAnswer,
                                        choiceClass,
                                        hasInlineStyle: !!inlineStyle,
                                        reviewMode,
                                        questionObject: {
                                            id: q.id,
                                            correctAnswer: q.correctAnswer,
                                            hasExplanation: !!q.explanation
                                        }
                                    });
                                }

                                return `
                                    <label class="${choiceClass}" for="q${questionNum}_${key}" style="${inlineStyle}">
                                        <input
                                            type="radio"
                                            name="question${questionNum}"
                                            id="q${questionNum}_${key}"
                                            value="${key}"
                                            ${reviewMode ? 'disabled' : ''}
                                            ${isUserAnswer ? 'checked' : ''}
                                            onchange="selectAnswer(${questionNum}, '${key}')"
                                        >
                                        <span class="answer-text">
                                            <strong>${key}.</strong> ${q.answers[key]}
                                            ${reviewMode && isCorrectAnswer ? ' <span class="answer-indicator" style="display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; font-weight: 600; padding: 0.125rem 0.5rem; border-radius: 4px; margin-left: 0.5rem; background: #10b981; color: white;"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 8 6 11 13 4"></polyline></svg> Correct</span>' : ''}
                                            ${reviewMode && isUserAnswer && !isCorrect ? ' <span class="answer-indicator wrong" style="display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; font-weight: 600; padding: 0.125rem 0.5rem; border-radius: 4px; margin-left: 0.5rem; background: #ef4444; color: white;"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><line x1="4" y1="4" x2="12" y2="12"></line><line x1="12" y1="4" x2="4" y2="12"></line></svg> Your answer</span>' : ''}
                                            ${reviewMode && isUserAnswer && isCorrect ? ' <span class="answer-indicator" style="display: inline-flex; align-items: center; gap: 0.25rem; font-size: 0.75rem; font-weight: 600; padding: 0.125rem 0.5rem; border-radius: 4px; margin-left: 0.5rem; background: #10b981; color: white;"><svg width="12" height="12" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 8 6 11 13 4"></polyline></svg> Your answer</span>' : ''}
                                        </span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                        ${reviewMode ? `
                            <div class="review-explanation" style="margin-top: 1rem; padding: 0.875rem 1rem; background: ${isCorrect ? '#f0fdf4' : userAnswer ? '#fef2f2' : '#fff7ed'}; border: 1px solid ${isCorrect ? '#dcfce7' : userAnswer ? '#fee2e2' : '#fed7aa'}; border-left: 3px solid ${isCorrect ? '#10b981' : userAnswer ? '#ef4444' : '#f59e0b'}; border-radius: 6px;">
                                <!-- Result Header -->
                                <div style="display: flex; align-items: center; gap: 0.625rem;">
                                    <div style="display: flex; align-items: center; justify-content: center; width: 28px; height: 28px; border-radius: 50%; background: ${isCorrect ? '#dcfce7' : userAnswer ? '#fee2e2' : '#fed7aa'}; flex-shrink: 0;">
                                        ${isCorrect ? `
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                                <polyline points="20 6 9 17 4 12"></polyline>
                                            </svg>
                                        ` : userAnswer ? `
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                                <line x1="18" y1="6" x2="6" y2="18"></line>
                                                <line x1="6" y1="6" x2="18" y2="18"></line>
                                            </svg>
                                        ` : `
                                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#f59e0b" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                                <circle cx="12" cy="12" r="10"></circle>
                                                <line x1="12" y1="16" x2="12" y2="12"></line>
                                                <line x1="12" y1="8" x2="12.01" y2="8"></line>
                                            </svg>
                                        `}
                                    </div>
                                    <div style="flex: 1; min-width: 0;">
                                        <div style="font-size: 0.8125rem; font-weight: 600; color: ${isCorrect ? '#166534' : userAnswer ? '#991b1b' : '#ea580c'}; margin-bottom: 0.125rem;">
                                            ${userAnswer ? (isCorrect ? 'Correct' : 'Incorrect') : 'Not Answered'}
                                        </div>
                                        <div style="font-size: 0.8125rem; color: #374151; line-height: 1.4;">
                                            ${userAnswer ? (
                                                isCorrect
                                                    ? `Answer: <strong style="color: #10b981;">${userAnswer}</strong>`
                                                    : `Your answer: <strong style="color: #ef4444; text-decoration: line-through;">${userAnswer}</strong> ¬∑ Correct: <strong style="color: #10b981; background: #dcfce7; padding: 0.0625rem 0.375rem; border-radius: 3px;">${correctAnswer}</strong>`
                                            ) : `Correct answer: <strong style="color: #10b981; background: #dcfce7; padding: 0.0625rem 0.375rem; border-radius: 3px;">${correctAnswer}</strong>`}
                                        </div>
                                    </div>
                                </div>

                                <!-- Explanation -->
                                ${q.explanation ? `
                                    <div style="margin-top: 0.875rem; padding-top: 0.875rem; border-top: 1px solid ${isCorrect ? '#dcfce7' : userAnswer ? '#fee2e2' : '#fed7aa'};">
                                        <div style="font-size: 0.9375rem; font-weight: 600; color: #000000; margin-bottom: 0.75rem; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
                                            Explanation
                                        </div>
                                        <div style="font-size: 0.9375rem; line-height: 1.6; color: #000000; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; font-weight: 400;">
                                            ${q.explanation}
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        ` : ''}
                    </div>
                `;

                // Log first question HTML to see what's being generated
                if (idx === 0) {
                    console.log('üîç First question HTML (first 500 chars):', questionHTML.substring(0, 500));
                }
            });

            console.log('‚úÖ Finished rendering', questions.length, 'questions. Review mode:', reviewMode);
            questionSection.innerHTML = questionHTML;

            // Typeset math after content is rendered
            if (window.MathJax) {
                MathJax.typesetPromise([passageSection, questionSection]).catch(err => {
                    console.error('MathJax typesetting failed:', err);
                });
            }
        }

        function highlightUnderlinedPortion(passageElement, currentQuestionNum, questionsInPassage) {
            // Find the index of current question within this passage (0-based)
            const indexInPassage = questionsInPassage.indexOf(currentQuestionNum);
            if (indexInPassage === -1) return;

            // Get all underlined elements in this passage
            const allUnderlined = passageElement.querySelectorAll('.passage-text u');

            // Highlight the underlined portion at this index
            if (allUnderlined[indexInPassage]) {
                allUnderlined[indexInPassage].classList.add('highlighted');
            }
        }

        function selectAnswer(questionNum, answer) {
            answers[`q${questionNum}`] = answer;

            // Add visual feedback - highlight selected answer
            const questionElement = document.getElementById(`question${questionNum}`);
            if (questionElement) {
                questionElement.querySelectorAll('.answer-choice').forEach(choice => {
                    choice.classList.remove('selected');
                });
                const selectedLabel = questionElement.querySelector(`label[for="q${questionNum}_${answer}"]`);
                if (selectedLabel) {
                    selectedLabel.classList.add('selected');
                }
            }

            updateQuestionGrid();
        }

        function updateDisplay() {
            // Hide all questions and passages
            document.querySelectorAll('.question').forEach(q => q.classList.remove('active'));
            document.querySelectorAll('.passage-content').forEach(p => p.classList.remove('active'));

            // Remove all previous highlights from underlined portions
            document.querySelectorAll('.passage-text u').forEach(u => {
                u.classList.remove('highlighted');
            });

            // Show current question
            const questionElement = document.getElementById(`question${currentQuestion}`);
            if (questionElement) {
                questionElement.classList.add('active');

                // Show corresponding passage
                if (hasPassages) {
                    // Find which passage contains this question number
                    let activePassage = null;
                    document.querySelectorAll('.passage-content').forEach(p => {
                        const questionsInPassage = p.dataset.questions.split(',').map(Number);
                        if (questionsInPassage.includes(currentQuestion)) {
                            p.classList.add('active');
                            activePassage = p;

                            // Highlight the corresponding underlined portion
                            highlightUnderlinedPortion(p, currentQuestion, questionsInPassage);
                        }
                    });

                    // Scroll the active passage into view
                    if (activePassage) {
                        setTimeout(() => {
                            activePassage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    }
                }
            }

            // Update navigation
            const currentIdx = questions.findIndex(q => (q.question_number || 0) === currentQuestion);
            const isFirstQuestion = currentIdx === 0;
            const isLastQuestion = currentIdx === questions.length - 1;

            document.getElementById('prevBtn').disabled = isFirstQuestion;

            const nextBtn = document.getElementById('nextBtn');

            if (isLastQuestion) {
                nextBtn.textContent = 'Review Answers';
                nextBtn.onclick = showQuestionModal;
            } else {
                nextBtn.textContent = 'NEXT ‚Ä∫';
                nextBtn.onclick = nextQuestion;
            }

            // Show answered count instead of current question number for counter
            const answeredCount = Object.keys(answers).length;

            // In review mode, show correct/incorrect stats
            if (reviewMode && reviewModeData) {
                let correctCount = 0;
                let incorrectCount = 0;
                let unansweredCount = 0;

                questions.forEach((q, idx) => {
                    const questionNum = q.question_number || (idx + 1);
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        if (isCorrect) correctCount++;
                        else incorrectCount++;
                    } else {
                        unansweredCount++;
                    }
                });

                document.getElementById('questionCounter').innerHTML = `
                    <div style="display: inline-flex; align-items: center; gap: 0.5rem; font-size: 0.9rem; font-weight: 500;">
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem;">
                            <span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; background: #dcfce7;">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                    <polyline points="20 6 9 17 4 12"></polyline>
                                </svg>
                            </span>
                            <span style="color: rgba(255, 255, 255, 0.95);">${correctCount}</span>
                            <span style="color: rgba(255, 255, 255, 0.6); font-weight: 400;">correct</span>
                        </span>
                        <span style="color: rgba(255, 255, 255, 0.3);">¬∑</span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem;">
                            <span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; background: #fee2e2;">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                    <line x1="18" y1="6" x2="6" y2="18"></line>
                                    <line x1="6" y1="6" x2="18" y2="18"></line>
                                </svg>
                            </span>
                            <span style="color: rgba(255, 255, 255, 0.95);">${incorrectCount}</span>
                            <span style="color: rgba(255, 255, 255, 0.6); font-weight: 400;">incorrect</span>
                        </span>
                        <span style="color: rgba(255, 255, 255, 0.3);">¬∑</span>
                        <span style="display: inline-flex; align-items: center; gap: 0.25rem;">
                            <span style="display: inline-flex; align-items: center; justify-content: center; width: 18px; height: 18px; border-radius: 50%; background: rgba(255, 255, 255, 0.15);">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="rgba(255, 255, 255, 0.6)" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                                    <circle cx="12" cy="12" r="10"></circle>
                                    <line x1="4" y1="12" x2="20" y2="12"></line>
                                </svg>
                            </span>
                            <span style="color: rgba(255, 255, 255, 0.95);">${unansweredCount}</span>
                            <span style="color: rgba(255, 255, 255, 0.6); font-weight: 400;">unanswered</span>
                        </span>
                    </div>
                `;
            } else {
                document.getElementById('questionCounter').textContent = `${answeredCount} of ${totalQuestions}`;
            }

            document.getElementById('itemNumber').textContent = `Item ${currentQuestion}`;

            updateFlagButton();

            // Typeset math in the currently visible question and passage
            if (window.MathJax) {
                const questionElement = document.getElementById(`question${currentQuestion}`);
                const activePassage = document.querySelector('.passage-content.active');
                const elementsToTypeset = [questionElement, activePassage].filter(el => el);
                if (elementsToTypeset.length > 0) {
                    MathJax.typesetPromise(elementsToTypeset).catch(err => {
                        console.error('MathJax typesetting failed:', err);
                    });
                }
            }
        }

        function nextQuestion() {
            // Find current question index
            const currentIdx = questions.findIndex(q => (q.question_number || 0) === currentQuestion);
            if (currentIdx >= 0 && currentIdx < questions.length - 1) {
                currentQuestion = questions[currentIdx + 1].question_number || (currentIdx + 2);
                updateDisplay();
            }
        }

        function previousQuestion() {
            // Find current question index
            const currentIdx = questions.findIndex(q => (q.question_number || 0) === currentQuestion);
            if (currentIdx > 0) {
                currentQuestion = questions[currentIdx - 1].question_number || currentIdx;
                updateDisplay();
            }
        }

        function goToQuestion(questionNum) {
            // Check if question exists in questions array
            const questionExists = questions.some(q => (q.question_number || 0) === questionNum);
            if (questionExists) {
                currentQuestion = questionNum;
                updateDisplay();
                closeQuestionModal();
            }
        }

        function toggleFlag() {
            if (flaggedQuestions.has(currentQuestion)) {
                flaggedQuestions.delete(currentQuestion);
            } else {
                flaggedQuestions.add(currentQuestion);
            }
            updateFlagButton();
            updateQuestionGrid();
        }

        function updateFlagButton() {
            const flagBtn = document.getElementById('flagBtn');
            const flagIcon = `<span class="icon">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16">
                    <path d="M3 2C3 1.44772 3.44772 1 4 1C4.55228 1 5 1.44772 5 2V3H13C13.3466 3 13.6684 3.17959 13.8507 3.47427C14.0329 3.76894 14.0494 4.13681 13.8944 4.44721L11.618 9L13.8944 13.5528C14.0494 13.8632 14.0329 14.2311 13.8507 14.5257C13.6684 14.8204 13.3466 15 13 15H5V16C5 16.5523 4.55228 17 4 17C3.44772 17 3 16.5523 3 16V2Z"/>
                </svg>
            </span>`;

            if (flaggedQuestions.has(currentQuestion)) {
                flagBtn.innerHTML = flagIcon + 'Unflag';
                flagBtn.classList.add('flagged');
            } else {
                flagBtn.innerHTML = flagIcon + 'Flag';
                flagBtn.classList.remove('flagged');
            }
        }

        function showQuestionModal() {
            document.getElementById('questionModal').style.display = 'block';
            generateQuestionGrid();
        }

        function closeQuestionModal() {
            document.getElementById('questionModal').style.display = 'none';
        }

        function generateQuestionGrid() {
            const grid = document.getElementById('questionGrid');
            grid.innerHTML = '';

            // Use actual question numbers from questions array
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1);
                const item = document.createElement('div');
                item.className = 'question-nav-item';
                item.textContent = questionNum;
                item.onclick = () => goToQuestion(questionNum);

                if (questionNum === currentQuestion) {
                    item.classList.add('current');
                } else if (answers[`q${questionNum}`]) {
                    item.classList.add('answered');
                }

                if (flaggedQuestions.has(questionNum)) {
                    item.classList.add('flagged');
                }

                // In review mode, add correct/incorrect styling
                if (reviewMode && reviewModeData) {
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        item.classList.add(isCorrect ? 'review-correct' : 'review-incorrect');
                    } else {
                        item.classList.add('review-unanswered');
                    }
                }

                grid.appendChild(item);
            });
        }
        function generateSidebarQuestions() {
            const sidebar = document.getElementById('sidebarQuestions');
            if (!sidebar) {
                console.log('‚ö†Ô∏è Sidebar element not found, skipping sidebar generation');
                return;
            }

            sidebar.innerHTML = '';

            // Use actual question numbers from questions array
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1);
                const item = document.createElement('div');
                item.className = 'sidebar-question-item';
                item.textContent = questionNum;
                item.onclick = () => goToQuestion(questionNum);

                if (questionNum === currentQuestion) {
                    item.classList.add('current');
                } else if (answers[`q${questionNum}`]) {
                    item.classList.add('answered');
                } else if (flaggedQuestions.has(questionNum)) {
                    item.classList.add('flagged');
                }

                // In review mode, add correct/incorrect styling
                if (reviewMode && reviewModeData) {
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        item.classList.add(isCorrect ? 'review-correct' : 'review-incorrect');
                    } else {
                        item.classList.add('review-unanswered');
                    }
                }

                sidebar.appendChild(item);
            });
        }

        function toggleSidebar() {
            // Sidebar is always visible now, this could be used for future expand/collapse
            showQuestionModal();
        }

        function updateQuestionGrid() {
            generateSidebarQuestions();
            if (document.getElementById('questionModal').style.display === 'block') {
                generateQuestionGrid();
            }
        }

        function startTimer() {
            const timerElement = document.getElementById('timer');
            if (!timerElement) {
                console.error('Timer element not found!');
                return;
            }

            console.log('‚è∞ Starting timer with duration:', duration, 'minutes');

            // Set initial display immediately
            const initialMinutes = Math.floor(timeLeft / 60);
            const initialSeconds = timeLeft % 60;
            timerElement.textContent = `${initialMinutes}:${initialSeconds.toString().padStart(2, '0')}`;

            // Update every second
            setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    // Red color when under 5 minutes
                    if (timeLeft <= 300) {
                        timerElement.style.color = '#dc2626';
                    }
                } else if (timeLeft === 0) {
                    timerElement.textContent = '0:00';
                    console.log('Time is up!');
                }
            }, 1000);
        }

        function confirmEndSection() {
            console.log('üî¥ confirmEndSection called');
            const unanswered = totalQuestions - Object.keys(answers).length;
            const warning = document.getElementById('unansweredWarning');

            console.log('üìä Stats:', { totalQuestions, answeredCount: Object.keys(answers).length, unanswered });

            if (unanswered > 0) {
                warning.textContent = `You have ${unanswered} unanswered question${unanswered > 1 ? 's' : ''}.`;
            } else {
                warning.textContent = '';
            }

            const modal = document.getElementById('confirmModal');
            console.log('üì¶ Modal element:', modal);
            modal.style.display = 'block';
            console.log('‚úÖ Modal should now be visible');
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }

        function endSection() {
            console.log('üü¢ endSection called');
            closeConfirmModal();

            // Calculate score for current section
            let correct = 0;
            questions.forEach((q, idx) => {
                const questionNum = idx + 1;
                const userAnswer = answers[`q${questionNum}`];
                if (userAnswer === q.correctAnswer) {
                    correct++;
                }
            });

            const percentage = Math.round((correct / totalQuestions) * 100);

            console.log('üìà Score calculated:', { correct, total: totalQuestions, percentage });

            // Store current section results
            const currentResults = {
                section,
                correct,
                total: totalQuestions,
                percentage,
                answers,
                flagged: Array.from(flaggedQuestions),
                questions: questions.map((q, idx) => ({
                    questionNum: q.question_number, // Use actual question_number from database
                    userAnswer: answers[`q${idx + 1}`],
                    correctAnswer: q.correctAnswer,
                    isCorrect: answers[`q${idx + 1}`] === q.correctAnswer
                }))
            };

            // Get all previous results
            const allResults = JSON.parse(sessionStorage.getItem('practiceTestAllResults') || '[]');
            allResults.push(currentResults);
            sessionStorage.setItem('practiceTestAllResults', JSON.stringify(allResults));

            // Determine next section
            const sectionOrder = ['english', 'math', 'reading', 'science'];
            const currentIndex = sectionOrder.indexOf(section);
            const isFullTest = section === 'full';

            console.log('üéØ Section ended:', {
                section,
                sectionType: typeof section,
                currentIndex,
                sectionOrder,
                nextAvailable: currentIndex < sectionOrder.length - 1
            });

            // Always progress through sections (full test simulation)
            if (currentIndex >= 0 && currentIndex < sectionOrder.length - 1) {
                // Load next section
                const nextSection = sectionOrder[currentIndex + 1];
                console.log('üì§ Sending NEXT_SECTION message:', nextSection);
                const message = {
                    type: 'PRACTICE_TEST_NEXT_SECTION',
                    nextSection: nextSection,
                    currentResults: currentResults
                };
                console.log('üì¶ Full message object:', message);
                window.parent.postMessage(message, '*');
                console.log('‚úÖ Message posted to parent');
            } else {
                // Test complete - all 4 sections done
                console.log('üì§ Sending COMPLETE message - All sections finished');
                sessionStorage.setItem('practiceTestResults', JSON.stringify({
                    allSections: allResults,
                    totalCorrect: allResults.reduce((sum, r) => sum + r.correct, 0),
                    totalQuestions: allResults.reduce((sum, r) => sum + r.total, 0)
                }));

                window.parent.postMessage({ type: 'PRACTICE_TEST_COMPLETE' }, '*');
                console.log('‚úÖ Complete message posted to parent');
            }
        }

        // Sliding Navigator Panel Functions
        function toggleNavigator() {
            const panel = document.getElementById('navigatorPanel');
            const testMain = document.querySelector('.test-main');
            const sidebar = document.querySelector('.question-sidebar');
            const isOpen = panel.classList.contains('open');

            if (isOpen) {
                panel.classList.remove('open');
                testMain.classList.remove('navigator-open');
                sidebar.classList.remove('navigator-open');
            } else {
                panel.classList.add('open');
                testMain.classList.add('navigator-open');
                sidebar.classList.add('navigator-open');
                populateNavigator();
            }
        }

        function populateNavigator() {
            console.log('üîç populateNavigator called');
            const navigatorContent = document.getElementById('navigatorContent');
            if (!navigatorContent) {
                console.error('Navigator content element not found');
                return;
            }

            navigatorContent.innerHTML = '';
            console.log('‚úÖ Found navigatorContent, cleared it');

            if (!questions || questions.length === 0) {
                console.error('‚ùå No questions to populate');
                navigatorContent.innerHTML = '<div style="padding: 1rem; text-align: center; color: #1a1a1a; font-weight: 600;">No questions loaded</div>';
                return;
            }

            console.log(`üìù Populating ${questions.length} questions`);
            console.log('Review mode:', reviewMode);
            console.log('Review mode data:', reviewModeData);

            // Add a header to show it's working
            const headerDiv = document.createElement('div');
            headerDiv.style.padding = '0.5rem';
            headerDiv.style.background = '#f9fafb';
            headerDiv.style.marginBottom = '0.5rem';
            headerDiv.style.borderRadius = '4px';
            headerDiv.style.fontSize = '0.75rem';
            headerDiv.style.color = '#6b7280';
            headerDiv.textContent = `${questions.length} questions loaded`;
            navigatorContent.appendChild(headerDiv);
            console.log('‚úÖ Header added');

            let itemsCreated = 0;
            let errorCount = 0;

            questions.forEach((q, idx) => {
                try {
                    const questionNum = idx + 1;

                    // Check if in review mode
                    const userAnswerKey = `q${questionNum}`;
                    const userAnswer = reviewMode && reviewModeData ? reviewModeData.userAnswers[userAnswerKey] : null;
                    const correctAnswer = q.correctAnswer;
                    const isCorrect = reviewMode && userAnswer === correctAnswer;
                    const isIncorrect = reviewMode && userAnswer && userAnswer !== correctAnswer;
                    const isSkipped = reviewMode && !userAnswer;
                    const isCurrent = questionNum === currentQuestion;
                    const isAnswered = answers[`q${questionNum}`];
                    const isFlagged = flaggedQuestions.has(questionNum);

                    const item = document.createElement('div');
                    item.className = 'navigator-question-item';
                    if (isCurrent) item.classList.add('current');
                    if (!reviewMode && isAnswered) item.classList.add('answered');
                    if (isFlagged) item.classList.add('flagged');

                    // Add review mode classes
                    if (reviewMode) {
                        if (isCorrect) item.classList.add('review-correct');
                        else if (isIncorrect) item.classList.add('review-incorrect');
                        else if (isSkipped) item.classList.add('review-skipped');
                    }

                    // Extract question preview - handle all question types
                    let questionPreview = 'Question ' + questionNum;

                    try {
                        // For questions with passages (English, Reading, Science)
                        if (q.passage) {
                            // Find ALL underlined portions in the passage
                            const underlineMatches = q.passage.match(/<u[^>]*>(.*?)<\/u>/gi);
                            if (underlineMatches && underlineMatches.length > 0) {
                                // Try to match this question to its underlined portion
                                let targetUnderline = null;

                                // First, try to find which underline corresponds to this question
                                // by looking for the question number in the passage structure
                                const passageQuestionNumbers = [];
                                let passageText = q.passage;

                                // Count questions in this passage to find relative position
                                questions.forEach((otherQ, otherIdx) => {
                                    if (otherQ.passage === q.passage) {
                                        passageQuestionNumbers.push(otherIdx);
                                    }
                                });

                                // Find this question's position within its passage
                                const positionInPassage = passageQuestionNumbers.indexOf(idx);

                                if (positionInPassage >= 0 && underlineMatches[positionInPassage]) {
                                    targetUnderline = underlineMatches[positionInPassage];
                                }

                                if (targetUnderline) {
                                    let underlinedText = targetUnderline.replace(/<[^>]+>/g, '').replace(/<\/?u[^>]*>/gi, '').trim();

                                    if (underlinedText.length > 0) {
                                        if (underlinedText.length > 50) {
                                            questionPreview = `...<u style="text-decoration: underline;">${underlinedText.substring(0, 47)}...</u>`;
                                        } else {
                                            questionPreview = `...<u style="text-decoration: underline;">${underlinedText}</u>...`;
                                        }
                                    }
                                }
                            }

                            // If still no preview, try to get question text from reading/science questions
                            if (questionPreview === 'Question ' + questionNum && q.text) {
                                const plainText = q.text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                                const withoutBrackets = plainText.replace(/\[.*?\]|\(.*?\)/g, '').trim();
                                if (withoutBrackets.length > 10) {
                                    questionPreview = withoutBrackets.substring(0, 50) + (withoutBrackets.length > 50 ? '...' : '');
                                }
                            }
                        } else if (q.text) {
                            // For non-passage questions (Math primarily)
                            const plainText = q.text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                            const withoutBrackets = plainText.replace(/\[.*?\]|\(.*?\)/g, '').trim();
                            if (withoutBrackets.length > 10) {
                                questionPreview = withoutBrackets.substring(0, 50) + (withoutBrackets.length > 50 ? '...' : '');
                            }
                        }
                    } catch (e) {
                        console.error('Error extracting preview for Q' + questionNum, e);
                        questionPreview = 'Question ' + questionNum;
                    }

                    // Status indicator for review mode
                    let statusIndicator = '';
                    if (reviewMode) {
                        if (isCorrect) {
                            statusIndicator = '<div style="width: 20px; height: 20px; border-radius: 50%; background: #dcfce7; border: 2px solid #86efac; display: flex; align-items: center; justify-content: center; color: #10b981; font-size: 0.75rem; font-weight: 600;">‚úì</div>';
                        } else if (isIncorrect) {
                            statusIndicator = '<div style="width: 20px; height: 20px; border-radius: 50%; background: #fee2e2; border: 2px solid #fecaca; display: flex; align-items: center; justify-content: center; color: #ef4444; font-size: 0.75rem; font-weight: 600;">‚úó</div>';
                        } else if (isSkipped) {
                            statusIndicator = '<div style="width: 20px; height: 20px; border-radius: 50%; background: #fef3c7; border: 2px solid #fde68a; display: flex; align-items: center; justify-content: center; color: #f59e0b; font-size: 0.75rem; font-weight: 600;">‚àí</div>';
                        }
                    }

                    item.innerHTML = `
                        <div class="navigator-question-header">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span class="navigator-question-number">Q${questionNum}</span>
                                ${statusIndicator}
                            </div>
                            <div class="navigator-question-status">
                                ${!reviewMode && isAnswered ? '<span class="navigator-status-badge answered">‚úì</span>' : ''}
                                ${isFlagged ? '<span class="navigator-status-badge flagged">‚öë</span>' : ''}
                            </div>
                        </div>
                        <div class="navigator-question-preview">${questionPreview}</div>
                    `;

                    item.onclick = () => {
                        currentQuestion = questionNum;
                        updateDisplay();
                        toggleNavigator();
                    };

                    navigatorContent.appendChild(item);
                    itemsCreated++;
                } catch (error) {
                    console.error(`‚ùå Error creating navigator item ${idx + 1}:`, error);
                    errorCount++;
                }
            });

            console.log(`‚úÖ Created and appended ${itemsCreated} question items`);
            if (errorCount > 0) {
                console.error(`‚ùå ${errorCount} errors occurred while creating items`);
            }
            console.log('Navigator content children:', navigatorContent.children.length);

            // Debug: Show first few items
            if (navigatorContent.children.length > 1) {
                console.log('Sample item HTML:', navigatorContent.children[1].outerHTML.substring(0, 200));
            }

            // Scroll to current question
            setTimeout(() => {
                const currentItem = navigatorContent.querySelector('.navigator-question-item.current');
                if (currentItem) {
                    currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const questionModal = document.getElementById('questionModal');
            const confirmModal = document.getElementById('confirmModal');

            if (event.target === questionModal) {
                closeQuestionModal();
            }
            if (event.target === confirmModal) {
                closeConfirmModal();
            }
        };

        // Prevent accidental page close
        window.addEventListener('beforeunload', function (e) {
            if (Object.keys(answers).length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            initTest();
        });
    </script>
</body>
</html>
