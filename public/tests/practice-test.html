<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Practice Test</title>
    <link rel="stylesheet" href="shared-test-styles.css">

    <style>
        /* Explanation content styling */
        .review-explanation {
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            font-size: 0.9375rem;
            line-height: 1.6;
            color: #000000;
            font-weight: 400;
        }

        /* Default: no bold for inline strong tags */
        .review-explanation strong {
            font-weight: 400;
            color: #000000;
        }

        /* "Why Other Answers Are Wrong:" header - make bold */
        .review-explanation > div > div:last-child > div > strong {
            font-size: 0.9375rem;
            font-weight: 600;
            color: #000000;
        }

        /* Individual wrong answer items */
        .review-explanation > div > div:last-child > div > div {
            font-size: 0.9375rem;
            line-height: 1.6;
            color: #000000;
            margin-bottom: 0.5rem;
            padding-left: 1rem;
            position: relative;
            font-weight: 400;
        }

        /* Choice labels (Choice A:, Choice B:, etc.) - make bold */
        .review-explanation > div > div:last-child > div > div strong {
            font-weight: 600;
            color: #000000;
        }

        .review-explanation > div > div:last-child > div > div::before {
            content: "‚Ä¢";
            position: absolute;
            left: 0;
            color: #000000;
            font-weight: 400;
        }

        .review-explanation > div > div:last-child > div > div:last-child {
            margin-bottom: 0;
        }
    </style>

    <!-- MathJax for math rendering -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)']],
                displayMath: [['\\[', '\\]']],
                processEscapes: true,
                processEnvironments: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            },
            startup: {
                pageReady: () => {
                    return MathJax.startup.defaultPageReady();
                }
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>
</head>
<body>
    <!-- Header outside container for full width -->
    <div class="test-header">
        <div class="header-content">
            <a href="/" class="logo" id="headerLogo">Nomi Academy</a>
            <div class="header-center"></div>
            <div class="header-right">
                <span class="question-counter">
                    <span class="question-counter-label">Answered</span>
                    <span class="question-counter-value" id="questionCounter">0 of 215</span>
                </span>
                <div class="timer-container">
                    <span class="timer-label">Total Time Left</span>
                    <div class="timer" id="timer">--:--</div>
                </div>
                <div id="sectionSwitcher" style="display: none;">
                    <select
                        id="sectionDropdown"
                        onchange="switchSection(this.value)"
                        style="
                            background: transparent;
                            border: none;
                            color: #ffffff;
                            font-size: 0.875rem;
                            font-weight: 600;
                            padding: 0.5rem 2.25rem 0.5rem 0.75rem;
                            border-radius: 6px;
                            cursor: pointer;
                            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
                            appearance: none;
                            background-image: url('data:image/svg+xml;charset=UTF-8,%3csvg width=\"14\" height=\"10\" viewBox=\"0 0 14 10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"%3e%3cpath d=\"M1 1.5L7 8L13 1.5\" stroke=\"%23ffffff\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/%3e%3c/svg%3e');
                            background-repeat: no-repeat;
                            background-position: right 0.75rem center;
                            transition: all 0.2s ease;
                        "
                        onmouseover="this.style.background='rgba(255, 255, 255, 0.15)'; this.style.backgroundImage='url(\'data:image/svg+xml;charset=UTF-8,%3csvg width=\"14\" height=\"10\" viewBox=\"0 0 14 10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"%3e%3cpath d=\"M1 1.5L7 8L13 1.5\" stroke=\"%23ffffff\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/%3e%3c/svg%3e\'); this.style.backgroundRepeat='no-repeat'; this.style.backgroundPosition='right 0.75rem center'; this.style.backdropFilter='blur(10px)';"
                        onmouseout="this.style.background='transparent'; this.style.backgroundImage='url(\'data:image/svg+xml;charset=UTF-8,%3csvg width=\"14\" height=\"10\" viewBox=\"0 0 14 10\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"%3e%3cpath d=\"M1 1.5L7 8L13 1.5\" stroke=\"%23ffffff\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"/%3e%3c/svg%3e\'); this.style.backgroundRepeat='no-repeat'; this.style.backgroundPosition='right 0.75rem center'; this.style.backdropFilter='none';"
                    >
                        <option value="english" style="background: #0f172a; color: #ffffff;">English</option>
                        <option value="math" style="background: #0f172a; color: #ffffff;">Mathematics</option>
                        <option value="reading" style="background: #0f172a; color: #ffffff;">Reading</option>
                        <option value="science" style="background: #0f172a; color: #ffffff;">Science</option>
                    </select>
                </div>
                <button class="end-section-link" id="endButton" onclick="confirmEndSection()">
                    <span>End</span>
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none">
                        <rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div class="test-container">
        <div class="test-main">
            <!-- Questions Navigation - Outside container -->
            <div class="questions-nav-external">
                <div class="sidebar-icon" onclick="showQuestionModal()">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M9 2C8.44772 2 8 2.44772 8 3V4H6C4.89543 4 4 4.89543 4 6V20C4 21.1046 4.89543 22 6 22H18C19.1046 22 20 21.1046 20 20V6C20 4.89543 19.1046 4 18 4H16V3C16 2.44772 15.5523 2 15 2C14.4477 2 14 2.44772 14 3V4H10V3C10 2.44772 9.55228 2 9 2ZM6 8V20H18V8H6ZM8 11C8 10.4477 8.44772 10 9 10H15C15.5523 10 16 10.4477 16 11C16 11.5523 15.5523 12 15 12H9C8.44772 12 8 11.5523 8 11ZM9 14C8.44772 14 8 14.4477 8 15C8 15.5523 8.44772 16 9 16H15C15.5523 16 16 15.5523 16 15C16 14.4477 15.5523 14 15 14H9Z"/>
                    </svg>
                </div>
                <div class="sidebar-text">Questions</div>
            </div>

            <!-- Main Content -->
            <div class="test-content" id="testContent">
                <!-- Flag Bar -->
                <div class="flag-bar">
                    <span class="item-number" id="itemNumber">Item 1</span>
                    <button class="flag-button" id="flagBtn" onclick="toggleFlag()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none" style="margin-right: 0.25rem;">
                            <path d="M4 3C4 2.44772 4.44772 2 5 2C5.55228 2 6 2.44772 6 3V4H15C15.3466 4 15.6684 4.17959 15.8507 4.47427C16.0329 4.76894 16.0494 5.13681 15.8944 5.44721L13.618 10L15.8944 14.5528C16.0494 14.8632 16.0329 15.2311 15.8507 15.5257C15.6684 15.8204 15.3466 16 15 16H6V21C6 21.5523 5.55228 22 5 22C4.44772 22 4 21.5523 4 21V3Z"/>
                        </svg>
                        Flag
                    </button>
                </div>

                <!-- Hidden image upload section template -->
                <div id="imageUploadSection" style="display: none;">
                    <div class="image-upload-container">
                        <p>Need to show work? Upload an image of your scratch paper.</p>
                        <input type="file" accept="image/*" id="imageUpload" style="display: none;">
                        <button onclick="document.getElementById('imageUpload').click()">Upload Image</button>
                    </div>
                </div>

                <!-- Passages Section -->
                <div class="passage-section" id="passageSection">
                    <!-- Passage content will be injected here -->
                </div>

                <!-- Questions Section -->
                <div class="question-section" id="questionSection">
                    <!-- Question content will be injected here -->
                </div>

                <!-- Navigation inside content -->
                <div class="navigation" style="display: flex; align-items: center; justify-content: space-between;">
                    <div style="flex: 1;"></div>
                    <div id="questionStatusIndicator" style="display: none; flex-direction: row; align-items: center; justify-content: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 700; color: #ef4444; flex: 1; text-align: center;">
                        <svg width="18" height="18" viewBox="0 0 24 24" fill="currentColor" style="flex-shrink: 0;">
                            <circle cx="12" cy="12" r="10" fill="currentColor"/>
                            <path d="M15 9l-6 6M9 9l6 6" stroke="white" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                        <span id="questionStatusText" style="line-height: 1;">Wrong</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 0.5rem; flex: 1; justify-content: flex-end;">
                        <button
                            id="explanationNavBtn"
                            onclick="toggleCurrentExplanation()"
                            style="display: none; background: #ffffff; border: 1px solid #e2e8f0; color: #0f172a; font-size: 0.875rem; font-weight: 600; cursor: pointer; padding: 0.5rem 1rem; border-radius: 8px; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; transition: all 0.2s ease; box-shadow: 0 3px 0 0 rgba(0, 0, 0, 0.1);"
                            onmouseover="this.style.background='#f8fafc'; this.style.borderColor='#cbd5e1'; this.style.boxShadow='0 3px 0 0 rgba(0, 0, 0, 0.15)';"
                            onmouseout="this.style.background='#ffffff'; this.style.borderColor='#e2e8f0'; this.style.boxShadow='0 3px 0 0 rgba(0, 0, 0, 0.1)';"
                        >
                            Explanation
                        </button>
                        <button class="nav-button" id="prevBtn" onclick="previousQuestion()" disabled style="padding: 0.5rem 1rem; font-size: 0.875rem;">‚Äπ PREV</button>
                        <button class="nav-button primary" id="nextBtn" onclick="nextQuestion()" style="padding: 0.5rem 1rem; font-size: 0.875rem;">NEXT ‚Ä∫</button>
                    </div>
                </div>
            </div>

            <!-- Question Sidebar -->
            <div class="question-sidebar">
                <div class="sidebar-icon" onclick="toggleNavigator()">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="3" y1="6" x2="21" y2="6"></line>
                        <line x1="3" y1="12" x2="21" y2="12"></line>
                        <line x1="3" y1="18" x2="21" y2="18"></line>
                    </svg>
                </div>
                <div class="sidebar-text" onclick="toggleNavigator()">Index</div>
                <div class="sidebar-divider"></div>
                <div class="sidebar-questions" id="sidebarQuestions"></div>
            </div>

            <!-- Sliding Question Navigator Panel -->
            <div class="question-navigator-panel" id="navigatorPanel">
                <div class="navigator-header">
                    <h3>Question Navigator</h3>
                    <button class="navigator-close" onclick="toggleNavigator()">‚úï</button>
                </div>
                <div class="navigator-content" id="navigatorContent">
                    <!-- Questions will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Question Navigator Modal -->
    <div class="modal" id="questionModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">Question Navigator</h3>
                <button class="close" onclick="closeQuestionModal()">√ó</button>
            </div>
            <div class="question-grid" id="questionGrid"></div>
            <div class="modal-footer">
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color current"></div>
                        <span>Current</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color answered"></div>
                        <span>Answered</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color flagged"></div>
                        <span>Flagged</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal" id="confirmModal">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div class="modal-header">
                <h3 class="modal-title">End Section</h3>
                <button class="close" onclick="closeConfirmModal()">√ó</button>
            </div>
            <div class="modal-body">
                <p>Are you sure you want to end this section?</p>
                <p id="unansweredWarning" class="warning-text"></p>
                <div class="modal-actions">
                    <button class="nav-button" onclick="closeConfirmModal()">Cancel</button>
                    <button class="nav-button primary" onclick="endSection()">End Section</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Review mode state
        let reviewMode = false;
        let reviewModeData = null;

        // Load test data from sessionStorage
        let questions = JSON.parse(sessionStorage.getItem('practiceTestQuestions') || '[]');
        let section = sessionStorage.getItem('practiceTestSection') || 'english';
        const currentSection = section; // For image upload functionality
        let testNumber = sessionStorage.getItem('practiceTestNumber') || '1';
        let duration = parseInt(sessionStorage.getItem('practiceTestDuration') || '45');

        // Listen for review mode data from parent
        window.addEventListener('message', function(event) {
            if (event.data.type === 'LOAD_REVIEW_MODE') {
                console.log('üì® Received LOAD_REVIEW_MODE message:', event.data);
                reviewMode = true;
                reviewModeData = event.data;

                // Hide logo in review mode
                const headerLogo = document.getElementById('headerLogo');
                if (headerLogo) {
                    headerLogo.style.display = 'none';
                }

                // Override test data with review data
                questions = event.data.questions;
                section = event.data.section;
                console.log('üì® Iframe received postMessage with testNumber:', event.data.testNumber);
                testNumber = event.data.testNumber || '1'; // Use provided test number, default to 1 for diagnostic
                duration = 0; // No timer in review mode

                console.log('üî¢ Using testNumber:', testNumber, 'for review mode (1=diagnostic, 2-7=practice tests 1-6)');

                console.log('‚úÖ Review mode enabled with', questions.length, 'questions');

                // Debug: Log first question structure to verify answers object
                if (questions.length > 0) {
                    const firstQ = questions[0];
                    console.log('üîç First question structure in iframe:', {
                        question_number: firstQ.question_number,
                        text: firstQ.text ? firstQ.text.substring(0, 50) : null,
                        has_answers: !!firstQ.answers,
                        answers_type: typeof firstQ.answers,
                        answers_keys: firstQ.answers ? Object.keys(firstQ.answers) : null,
                        answers_preview: firstQ.answers ? JSON.stringify(firstQ.answers).substring(0, 100) : null,
                        correctAnswer: firstQ.correctAnswer,
                        hasExplanation: !!firstQ.explanation,
                        allKeys: Object.keys(firstQ)
                    });
                }

                // Initialize test with review data
                initTest();

                // Jump to specific question if provided
                if (event.data.startingQuestion !== undefined && event.data.startingQuestion > 0) {
                    console.log('üéØ Jumping to question:', event.data.startingQuestion);
                    currentQuestion = event.data.startingQuestion;
                    sessionStorage.setItem('currentQuestion', currentQuestion);
                    console.log('üìç currentQuestion set to:', currentQuestion);
                    // Small delay to ensure DOM is ready
                    setTimeout(() => {
                        updateDisplay();
                        console.log('‚úÖ Display updated to question:', currentQuestion);
                    }, 50);
                }
            } else if (event.data.type === 'JUMP_TO_QUESTION') {
                // Handle jump to specific question
                if (event.data.questionIndex !== undefined && event.data.questionIndex >= 0 && event.data.questionIndex < questions.length) {
                    currentQuestion = event.data.questionIndex;
                    sessionStorage.setItem('currentQuestion', currentQuestion);
                    updateDisplay();
                }
            } else if (event.data.type === 'LOAD_NEXT_SECTION') {
                console.log('üì® Received LOAD_NEXT_SECTION message - reloading from sessionStorage');
                console.log('   Current state before reload:', {
                    section: section,
                    questionCount: questions.length,
                    answersCount: Object.keys(answers).length
                });

                // Reload questions and section from sessionStorage (updated by parent)
                const newQuestions = JSON.parse(sessionStorage.getItem('practiceTestQuestions') || '[]');
                const newSection = sessionStorage.getItem('practiceTestSection') || 'english';
                const newDuration = parseInt(sessionStorage.getItem('practiceTestDuration') || '45');

                console.log('   SessionStorage contains:', {
                    section: newSection,
                    questionCount: newQuestions.length,
                    duration: newDuration,
                    firstQuestionNum: newQuestions[0]?.question_number,
                    lastQuestionNum: newQuestions[newQuestions.length - 1]?.question_number
                });

                questions = newQuestions;
                section = newSection;
                duration = newDuration;

                console.log('‚úÖ Loaded next section:', {
                    section: section,
                    questionCount: questions.length,
                    duration: duration
                });

                // Reset test state for new section
                answers = {};  // Clear answers from previous section
                hasPassages = questions.some(q => q.passage);
                totalQuestions = questions.length;
                currentQuestion = questions.length > 0 ? (questions[0].question_number || 1) : 1;
                timeLeft = duration * 60;

                // Add/remove math-test class based on passages
                if (!hasPassages) {
                    document.body.classList.add('math-test');
                } else {
                    document.body.classList.remove('math-test');
                }

                // Re-render the test with new questions
                renderContent();
                updateDisplay();
                generateSidebarQuestions();
                startTimer();

                console.log('‚úÖ New section initialized and ready');
            }
        });

        // Notify parent that iframe is ready
        window.addEventListener('load', function() {
            window.parent.postMessage({ type: 'IFRAME_READY' }, '*');
        });

        // Debug logging
        console.log('Practice Test Debug:', {
            section: section,
            sectionType: typeof section,
            testNumber: testNumber,
            questionsLoaded: questions.length,
            duration: duration,
            durationFromStorage: sessionStorage.getItem('practiceTestDuration'),
            timeLeft: duration * 60,
            firstQuestion: questions[0],
            rawQuestionsFromStorage: sessionStorage.getItem('practiceTestQuestions'),
            allSessionStorage: {
                questions: sessionStorage.getItem('practiceTestQuestions'),
                section: sessionStorage.getItem('practiceTestSection'),
                testNumber: sessionStorage.getItem('practiceTestNumber'),
                duration: sessionStorage.getItem('practiceTestDuration')
            }
        });

        // State - will be recalculated in initTest for review mode
        let hasPassages = false;
        let totalQuestions = 0;
        let currentQuestion = 1;
        let answers = {};
        let flaggedQuestions = new Set();
        let timeLeft = duration * 60; // Convert to seconds

        // If no questions on initial load and not waiting for review mode, show error
        if (questions.length === 0 && !sessionStorage.getItem('waitingForReviewMode')) {
            console.error('‚ùå NO QUESTIONS LOADED');
            console.error('SessionStorage keys:', Object.keys(sessionStorage));
            console.error('SessionStorage practiceTestQuestions:', sessionStorage.getItem('practiceTestQuestions'));

            document.getElementById('questionSection').innerHTML = `
                <div style="padding: 3rem; text-align: center;">
                    <h2 style="color: #dc2626; margin-bottom: 1rem;">‚ö†Ô∏è No Questions Loaded</h2>
                    <p style="color: #6b7280; margin-bottom: 1rem;">The test data was not loaded properly.</p>
                    <button onclick="window.parent.postMessage({type: 'PRACTICE_TEST_COMPLETE'}, '*')"
                            style="background: #4299e1; color: white; border: none; padding: 0.75rem 1.5rem; border-radius: 6px; cursor: pointer; font-size: 1rem;">
                        Back to Tests
                    </button>
                </div>
            `;
        }

        // Initialize test
        function initTest() {
            console.log('üöÄ initTest called, questions.length:', questions.length);

            if (questions.length === 0) {
                console.log('‚ùå No questions found - timer will NOT start');
                document.getElementById('questionSection').innerHTML =
                    '<div style="padding: 2rem; text-align: center; color: #6b7280;">No questions loaded. Please go back and select a test.</div>';
                return;
            }

            console.log('‚úÖ Questions loaded, initializing test...');

            // Recalculate these values based on current questions array
            hasPassages = questions.some(q => q.passage);
            totalQuestions = questions.length;

            // Try to restore saved question position
            const savedQuestion = sessionStorage.getItem('currentQuestion');
            if (savedQuestion && parseInt(savedQuestion) > 0 && parseInt(savedQuestion) <= totalQuestions) {
                currentQuestion = parseInt(savedQuestion);
                console.log('üìç Restored saved question position:', currentQuestion);
            } else {
                currentQuestion = questions.length > 0 ? (questions[0].question_number || 1) : 1;
            }

            timeLeft = duration * 60;

            console.log('üìä Test configuration:', {
                hasPassages,
                totalQuestions,
                currentQuestion,
                section
            });

            // If in review mode, pre-fill answers
            if (reviewMode && reviewModeData) {
                console.log('üìù Pre-filling answers from review data');
                answers = { ...reviewModeData.userAnswers };
                console.log('‚úÖ Pre-filled answers:', answers);

                // Hide timer in review mode
                const timerContainer = document.querySelector('.timer-container');
                if (timerContainer) {
                    timerContainer.style.display = 'none';
                }

                // Hide "Answered" label in review mode
                const counterLabel = document.querySelector('.question-counter-label');
                if (counterLabel) {
                    counterLabel.style.display = 'none';
                }

                // Show section switcher and hide end button in review mode
                const sectionSwitcher = document.getElementById('sectionSwitcher');
                const endButton = document.querySelector('.end-section-link');
                if (sectionSwitcher && endButton) {
                    sectionSwitcher.style.display = 'block';
                    endButton.style.display = 'none';

                    // Set the current section in the dropdown
                    const sectionDropdown = document.getElementById('sectionDropdown');
                    if (sectionDropdown) {
                        sectionDropdown.value = section;
                    }
                }
            }

            // Add math-test class if no passages
            if (!hasPassages) {
                document.body.classList.add('math-test');
            }

            // Render questions and passages
            renderContent();
            updateDisplay();
            generateSidebarQuestions();

            // Only start timer if not in review mode
            if (!reviewMode) {
                startTimer();
            }
        }

        function renderContent() {
            console.log('üé® renderContent called, reviewMode:', reviewMode, 'hasReviewData:', !!reviewModeData);

            const passageSection = document.getElementById('passageSection');
            const questionSection = document.getElementById('questionSection');

            // Render passages if they exist
            if (hasPassages) {
                // Group questions by passage
                const passageGroups = {};
                questions.forEach((q, idx) => {
                    if (q.passage) {
                        if (!passageGroups[q.passage]) {
                            passageGroups[q.passage] = [];
                        }
                        passageGroups[q.passage].push(idx + 1);
                    }
                });

                let passageHTML = '';
                let passageNum = 1;

                // Sort passages by passage_number to maintain correct order
                const sortedPassages = Object.entries(passageGroups).sort((a, b) => {
                    const firstQuestionA = questions[a[1][0] - 1];
                    const firstQuestionB = questions[b[1][0] - 1];
                    const passageNumA = firstQuestionA.passage_number || Math.min(...a[1]);
                    const passageNumB = firstQuestionB.passage_number || Math.min(...b[1]);
                    return passageNumA - passageNumB;
                });

                sortedPassages.forEach(([passageKey, questionNums]) => {
                    // Get the first question in this passage group to access passage data
                    const firstQuestionIndex = questionNums[0] - 1;
                    const firstQuestion = questions[firstQuestionIndex];

                    // Get passage title and text
                    const passageTitle = firstQuestion.passage_title || '';
                    let passageContent = passageKey; // passageKey is the passage text

                    // Replace image placeholders with actual URLs
                    if (firstQuestion.passage_image_urls) {
                        passageContent = replaceImagePlaceholders(passageContent, firstQuestion.passage_image_urls);
                    }

                    // Normalize line breaks: handle \r\n\r\n (Windows) and \n\n (Unix)
                    const normalizedContent = passageContent.replace(/\r\n/g, '\n');
                    const paragraphs = normalizedContent.split('\n\n').filter(p => p.trim().length > 0);

                    // Only show title if it's meaningful (not generic like "English Passage 2")
                    const isGenericTitle = /^(English|Reading|Science|Math)\s+(Passage\s+)?\d+$/i.test(passageTitle);
                    const shouldShowTitle = passageTitle && !isGenericTitle;

                    passageHTML += `
                        <div class="passage-content" id="passage${passageNum}" data-questions="${questionNums.join(',')}">
                            ${shouldShowTitle ? `<h3 class="passage-title">${passageTitle}</h3>` : ''}
                            <div class="passage-text">
                                ${paragraphs.map(p => `<p>${p.trim()}</p>`).join('')}
                            </div>
                        </div>
                    `;
                    passageNum++;
                });

                // For Math/Science, prepend upload section to passage HTML
                if (section === 'math' || section === 'science') {
                    const uploadSectionHTML = document.getElementById('imageUploadSection').outerHTML;
                    passageSection.innerHTML = uploadSectionHTML + passageHTML;
                } else {
                    passageSection.innerHTML = passageHTML;
                }
            } else {
                // No passages - show upload section for Math/Science, hide for others
                if (section === 'math' || section === 'science') {
                    passageSection.style.display = 'flex';
                    const uploadSectionHTML = document.getElementById('imageUploadSection').outerHTML;
                    passageSection.innerHTML = uploadSectionHTML;
                } else {
                    passageSection.style.display = 'none';
                }
            }

            // Helper function to replace image placeholders with actual image tags
            function replaceImagePlaceholders(text, imageUrls) {
                if (!text || !imageUrls) {
                    console.log('‚ö†Ô∏è replaceImagePlaceholders: missing text or imageUrls', { hasText: !!text, hasUrls: !!imageUrls });
                    return text;
                }

                console.log('üñºÔ∏è replaceImagePlaceholders called with', Object.keys(imageUrls).length, 'image URLs');

                // Replace {{key}} placeholders with actual <img> tags
                let result = text;
                let replacementCount = 0;

                Object.keys(imageUrls).forEach(key => {
                    const placeholder = `{{${key}}}`;
                    const url = imageUrls[key];

                    if (text.includes(placeholder)) {
                        const imgTag = `<img src="${url}" alt="Figure or Table" class="passage-image" onerror="console.error('Failed to load image:', this.src)" onload="console.log('‚úì Image loaded:', this.src.substring(0, 60) + '...')" />`;
                        result = result.replace(new RegExp(placeholder, 'g'), imgTag);
                        replacementCount++;
                        console.log(`  ‚úì Replaced ${placeholder} with image from ${url.substring(0, 60)}...`);
                    } else {
                        console.log(`  ‚ö†Ô∏è Placeholder ${placeholder} not found in text`);
                    }
                });

                console.log(`‚úÖ Replaced ${replacementCount} image placeholders`);
                return result;
            }

            // Helper function to extract rhetorical question prompt
            function extractQuestionPrompt(text) {
                if (!text) return '';
                // Extract text inside brackets [...]
                const match = text.match(/\[([^\]]+)\]/);
                return match ? match[1] : text; // Return bracketed text if exists, otherwise full text
            }

            // Helper function to extract inline images from question text
            function extractInlineImages(text) {
                if (!text) return { cleanText: text, images: [] };

                // Match image URLs in the text (https://...jpg, https://...png, etc.)
                const imageUrlPattern = /(https?:\/\/[^\s]+\.(?:jpg|jpeg|png|gif|svg))/gi;
                const images = [];
                let cleanText = text;

                // Find all image URLs
                const matches = text.match(imageUrlPattern);
                if (matches) {
                    matches.forEach(url => {
                        images.push(url);
                        // Remove the URL from the text
                        cleanText = cleanText.replace(url, '');
                    });
                }

                // Clean up any double spaces left behind
                cleanText = cleanText.replace(/\s{2,}/g, ' ').trim();

                return { cleanText, images };
            }

            // Render questions
            console.log('üìù Starting question rendering. reviewMode:', reviewMode, 'questions:', questions.length);

            let questionHTML = '';
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1); // Use database question_number

                // CRITICAL: Ensure answers object exists
                // If answers is empty/null, the answer choices won't render!
                if (!q.answers || Object.keys(q.answers).length === 0) {
                    console.error(`‚ùå Question ${questionNum} has NO answers object! Cannot display choices.`, q);
                }

                const answerKeys = Object.keys(q.answers || {}).sort();
                let questionPrompt = extractQuestionPrompt(q.text);

                // Extract inline images from question text
                const { cleanText, images: inlineImages } = extractInlineImages(questionPrompt);
                questionPrompt = cleanText;

                // Replace image placeholders in question text (for Math/Science)
                if (q.image_url && questionPrompt) {
                    questionPrompt = replaceImagePlaceholders(questionPrompt, q.image_url);
                }

                // Debug: Log answers object for first few questions
                if (idx < 3) {
                    console.log(`üîç Question ${questionNum} answers object:`, {
                        has_answers: !!q.answers,
                        answers_type: typeof q.answers,
                        answers_keys: answerKeys,
                        answers_content: q.answers,
                        correctAnswer: q.correctAnswer,
                        correctAnswer_type: typeof q.correctAnswer
                    });
                }

                // In review mode, get user's answer and correctness
                const userAnswerKey = `q${questionNum}`;
                const userAnswer = reviewMode && reviewModeData ? reviewModeData.userAnswers[userAnswerKey] : null;
                const isCorrect = reviewMode && reviewModeData ? reviewModeData.correctnessMap[userAnswerKey] : null;
                const correctAnswer = q.correctAnswer;

                if (idx === 0) {
                    console.log('üîç First question render debug:', {
                        reviewMode,
                        hasReviewData: !!reviewModeData,
                        questionNum,
                        userAnswerKey,
                        userAnswer,
                        isCorrect,
                        correctAnswer,
                        hasExplanation: !!q.explanation,
                        explanation: q.explanation ? q.explanation.substring(0, 50) : null,
                        reviewModeData: reviewModeData ? Object.keys(reviewModeData) : null
                    });
                }

                if (idx === 0 && reviewMode) {
                    console.log('üîç ReviewModeData structure:', {
                        userAnswersKeys: reviewModeData ? Object.keys(reviewModeData.userAnswers || {}).slice(0, 5) : null,
                        correctnessMapKeys: reviewModeData ? Object.keys(reviewModeData.correctnessMap || {}).slice(0, 5) : null
                    });
                }

                // For English questions with passages, extract the underlined portion as context
                let underlinedContext = '';
                if (q.passage && q.passage.includes('<u>')) {
                    // Find the nth underlined portion (where n is the index of this question in the passage)
                    const underlinedPortions = q.passage.match(/<u>[^<]+<\/u>/g) || [];
                    const questionsWithSamePassage = questions.filter(x => x.passage === q.passage);
                    const indexInPassage = questionsWithSamePassage.findIndex(x => x.question_number === questionNum);

                    if (underlinedPortions[indexInPassage]) {
                        const underlinedText = underlinedPortions[indexInPassage].replace(/<\/?u>/g, '');
                        underlinedContext = `<div class="underlined-context" style="padding: 0.75rem 1rem; background: #fef9c3; border-left: 3px solid #fbbf24; border-radius: 4px; margin-bottom: 1rem; font-family: 'Georgia', serif; line-height: 1.6;">
                            <div style="font-size: 0.75rem; font-weight: 600; color: #92400e; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.375rem;">Underlined Portion:</div>
                            <div style="font-size: 0.9375rem; color: #78350f;">"${underlinedText}"</div>
                        </div>`;
                    }
                }

                questionHTML += `
                    <div class="question" id="question${questionNum}" data-passage="${hasPassages ? (questions.findIndex(x => x.passage === q.passage) + 1) : ''}">
                        ${underlinedContext}
                        ${questionPrompt ? `<div class="question-text">${questionPrompt}</div>` : ''}
                        ${q.image_url ? `<div class="question-image"><img src="${q.image_url}" alt="Question ${questionNum} diagram" /></div>` : ''}
                        ${inlineImages.length > 0 ? inlineImages.map(url => `<div class="question-image"><img src="${url}" alt="Question ${questionNum} figure" class="inline-question-image" onerror="console.error('Failed to load inline image:', this.src)" onload="console.log('‚úì Inline image loaded:', this.src.substring(0, 60) + '...')" /></div>`).join('') : ''}
                        <div class="answer-choices">
                            ${answerKeys.map(key => {
                                const isUserAnswer = reviewMode && userAnswer === key;
                                const isCorrectAnswer = reviewMode && correctAnswer === key;
                                let choiceClass = 'answer-choice';
                                let inlineStyle = '';

                                if (reviewMode) {
                                    if (isCorrectAnswer) {
                                        choiceClass += ' correct-answer';
                                        inlineStyle = '';
                                    }
                                    if (isUserAnswer && !isCorrect) {
                                        choiceClass += ' wrong-answer';
                                        inlineStyle = '';
                                    }
                                    if (isUserAnswer && isCorrect) {
                                        choiceClass += ' user-answer';
                                        inlineStyle = '';
                                    }
                                }

                                                // Debug first question's first answer choice
                                if (idx === 0 && key === answerKeys[0]) {
                                    console.log('üé® First question answer styling:', {
                                        questionNum,
                                        answerKeys,
                                        testingKey: key,
                                        correctAnswer,
                                        correctAnswerType: typeof correctAnswer,
                                        isCorrectAnswer,
                                        choiceClass,
                                        hasInlineStyle: !!inlineStyle,
                                        reviewMode,
                                        questionObject: {
                                            id: q.id,
                                            correctAnswer: q.correctAnswer,
                                            hasExplanation: !!q.explanation
                                        }
                                    });
                                }

                                // Check if answer is an image URL
                                const answerText = q.answers[key];
                                const isImageUrl = answerText && (answerText.startsWith('http') || answerText.startsWith('/')) &&
                                                   (answerText.includes('.jpg') || answerText.includes('.png') || answerText.includes('.jpeg') || answerText.includes('.gif') || answerText.includes('.svg'));

                                return `
                                    <label class="${choiceClass}" for="q${questionNum}_${key}" style="${inlineStyle}">
                                        <input
                                            type="radio"
                                            name="question${questionNum}"
                                            id="q${questionNum}_${key}"
                                            value="${key}"
                                            ${reviewMode ? 'disabled' : ''}
                                            ${isUserAnswer ? 'checked' : ''}
                                            onchange="selectAnswer(${questionNum}, '${key}')"
                                        >
                                        <span class="answer-text" style="display: flex; align-items: ${isImageUrl ? 'center' : 'flex-start'}; width: 100%;">
                                            <span style="flex: 1; display: flex; align-items: ${isImageUrl ? 'center' : 'flex-start'}; gap: 0.5rem;">
                                                <strong style="color: ${reviewMode && isCorrectAnswer ? '#10b981' : '#000000'}; flex-shrink: 0;">${key})</strong>
                                                ${isImageUrl
                                                    ? `<img src="${answerText}" alt="Answer choice ${key}" class="answer-choice-image" style="max-width: 200px; max-height: 100px; object-fit: contain;" onerror="console.error('Failed to load answer image:', this.src)" onload="console.log('‚úì Answer choice image loaded:', this.src.substring(0, 60) + '...')" />`
                                                    : `<span style="color: #000000; flex: 1;">${answerText}</span>`
                                                }
                                            </span>
                                            <span style="width: 28px; display: flex; align-items: flex-start; justify-content: center; flex-shrink: 0; margin-left: 0.5rem; padding-top: 0.125rem;">
                                                ${reviewMode && isCorrectAnswer ? '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>' : ''}
                                                ${reviewMode && isUserAnswer && !isCorrect ? '<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>' : ''}
                                            </span>
                                        </span>
                                    </label>
                                `;
                            }).join('')}
                        </div>
                        ${reviewMode ? `
                            <!-- Result Status -->
                            <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                                ${userAnswer && isCorrect ? `
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#10b981" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                        <polyline points="20 6 9 17 4 12"></polyline>
                                    </svg>
                                    <span style="font-size: 1rem; font-weight: 700; color: #10b981;">Good Job!</span>
                                ` : userAnswer && !isCorrect ? `
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="#ef4444" stroke-width="3" stroke-linecap="round" stroke-linejoin="round">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                    <span style="font-size: 1rem; font-weight: 700; color: #ef4444;">Wrong</span>
                                ` : ''}
                            </div>

                            <!-- Explanation Content (hidden by default) -->
                            ${q.explanation ? `
                                <div id="explanation-content-${questionNum}" style="display: none; margin-top: 0.75rem; padding: 1rem; background: #ffffff; border: 1px solid #e2e8f0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);">
                                    <div style="font-size: 0.875rem; line-height: 1.7; color: #0f172a; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;">
                                        ${q.explanation.replace(/\n\n+/g, '<br><br>').replace(/\n/g, ' ')}
                                    </div>
                                </div>
                            ` : ''}
                        ` : ''}
                    </div>
                `;

                // Log first question HTML to see what's being generated
                if (idx === 0) {
                    console.log('üîç First question HTML (first 500 chars):', questionHTML.substring(0, 500));
                }
            });

            console.log('‚úÖ Finished rendering', questions.length, 'questions. Review mode:', reviewMode);
            questionSection.innerHTML = questionHTML;

            // Typeset math after content is rendered
            if (window.MathJax) {
                MathJax.typesetPromise([passageSection, questionSection]).catch(err => {
                    console.error('MathJax typesetting failed:', err);
                });
            }
        }

        function highlightUnderlinedPortion(passageElement, currentQuestionNum, questionsInPassage) {
            // Find the index of current question within this passage (0-based)
            const indexInPassage = questionsInPassage.indexOf(currentQuestionNum);
            if (indexInPassage === -1) return;

            // Get all underlined elements in this passage
            const allUnderlined = passageElement.querySelectorAll('.passage-text u');

            // Highlight the underlined portion at this index
            if (allUnderlined[indexInPassage]) {
                allUnderlined[indexInPassage].classList.add('highlighted');
            }
        }

        function selectAnswer(questionNum, answer) {
            answers[`q${questionNum}`] = answer;

            // Add visual feedback - highlight selected answer
            const questionElement = document.getElementById(`question${questionNum}`);
            if (questionElement) {
                questionElement.querySelectorAll('.answer-choice').forEach(choice => {
                    choice.classList.remove('selected');
                });
                const selectedLabel = questionElement.querySelector(`label[for="q${questionNum}_${answer}"]`);
                if (selectedLabel) {
                    selectedLabel.classList.add('selected');
                }
            }

            updateQuestionGrid();
        }

        function toggleExplanation(questionNum) {
            const content = document.getElementById(`explanation-content-${questionNum}`);
            const btn = document.getElementById(`explanation-btn-${questionNum}`);

            if (content && btn) {
                if (content.style.display === 'none') {
                    content.style.display = 'block';
                    btn.textContent = 'Hide Explanation';
                } else {
                    content.style.display = 'none';
                    btn.textContent = 'Explanation';
                }
            }
        }

        function toggleCurrentExplanation() {
            console.log('üîò Toggle explanation clicked for question', currentQuestion);
            const content = document.getElementById(`explanation-content-${currentQuestion}`);
            const btn = document.getElementById('explanationNavBtn');

            console.log('üì¶ Content element:', content ? 'found' : 'NOT FOUND');
            console.log('üîò Button element:', btn ? 'found' : 'NOT FOUND');

            if (content && btn) {
                const isHidden = content.style.display === 'none' || content.style.display === '';
                console.log('üëÅÔ∏è Current display:', content.style.display, '- Will show?', isHidden);

                if (isHidden) {
                    content.style.display = 'block';
                    btn.textContent = 'Hide Explanation';
                    console.log('‚úÖ Explanation shown');
                } else {
                    content.style.display = 'none';
                    btn.textContent = 'Explanation';
                    console.log('‚úÖ Explanation hidden');
                }
            } else {
                console.error('‚ùå Could not find content or button element');
            }
        }

        function updateDisplay() {
            // Hide all questions and passages
            document.querySelectorAll('.question').forEach(q => q.classList.remove('active'));
            document.querySelectorAll('.passage-content').forEach(p => p.classList.remove('active'));

            // Remove all previous highlights from underlined portions
            document.querySelectorAll('.passage-text u').forEach(u => {
                u.classList.remove('highlighted');
            });

            // Show current question
            const questionElement = document.getElementById(`question${currentQuestion}`);
            console.log('üéØ Looking for question element:', `question${currentQuestion}`, 'found:', !!questionElement);

            if (questionElement) {
                questionElement.classList.add('active');
                console.log('‚úÖ Activated question:', currentQuestion);
                console.log('   Question element display:', window.getComputedStyle(questionElement).display);
                console.log('   Question element visibility:', window.getComputedStyle(questionElement).visibility);
                console.log('   Question element classes:', questionElement.className);
                console.log('   Question has content:', questionElement.innerHTML.length > 0 ? 'yes' : 'no', questionElement.innerHTML.length, 'chars');

                // Show corresponding passage
                if (hasPassages) {
                    // Find which passage contains this question number
                    let activePassage = null;
                    document.querySelectorAll('.passage-content').forEach(p => {
                        const questionsInPassage = p.dataset.questions.split(',').map(Number);
                        if (questionsInPassage.includes(currentQuestion)) {
                            p.classList.add('active');
                            activePassage = p;

                            // Highlight the corresponding underlined portion
                            highlightUnderlinedPortion(p, currentQuestion, questionsInPassage);
                        }
                    });

                    // Scroll the active passage into view
                    if (activePassage) {
                        setTimeout(() => {
                            activePassage.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }, 100);
                    }
                }
            } else {
                console.error('‚ùå Question element not found for question:', currentQuestion);
                console.error('   Available question elements:', Array.from(document.querySelectorAll('.question')).map(el => el.id));
            }

            // Update navigation
            const currentIdx = questions.findIndex((q, idx) => (q.question_number || (idx + 1)) === currentQuestion);
            const isFirstQuestion = currentIdx === 0;
            const isLastQuestion = currentIdx === questions.length - 1;

            console.log('üîç Navigation update:', { currentQuestion, currentIdx, isFirstQuestion, isLastQuestion });

            document.getElementById('prevBtn').disabled = isFirstQuestion;

            const nextBtn = document.getElementById('nextBtn');

            if (isLastQuestion) {
                nextBtn.textContent = 'Review Answers';
                nextBtn.onclick = showQuestionModal;
            } else {
                nextBtn.textContent = 'NEXT ‚Ä∫';
                nextBtn.onclick = nextQuestion;
            }

            // Show answered count instead of current question number for counter
            const answeredCount = Object.keys(answers).length;

            // In review mode, show correct/incorrect stats
            if (reviewMode && reviewModeData) {
                let correctCount = 0;
                let incorrectCount = 0;
                let unansweredCount = 0;

                questions.forEach((q, idx) => {
                    const questionNum = q.question_number || (idx + 1);
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        if (isCorrect) correctCount++;
                        else incorrectCount++;
                    } else {
                        unansweredCount++;
                    }
                });

                document.getElementById('questionCounter').innerHTML = `
                    <div style="display: inline-flex; align-items: center; gap: 0.75rem; font-size: 0.875rem; font-weight: 500;">
                        <span style="display: inline-flex; align-items: center; gap: 0.375rem;">
                            <span style="color: #ffffff; font-weight: 600;">${correctCount}</span>
                            <span style="color: #ffffff; font-weight: 400;">correct</span>
                        </span>
                        <span style="color: rgba(255, 255, 255, 0.5);">¬∑</span>
                        <span style="display: inline-flex; align-items: center; gap: 0.375rem;">
                            <span style="color: #ffffff; font-weight: 600;">${incorrectCount}</span>
                            <span style="color: #ffffff; font-weight: 400;">incorrect</span>
                        </span>
                        <span style="color: rgba(255, 255, 255, 0.5);">¬∑</span>
                        <span style="display: inline-flex; align-items: center; gap: 0.375rem;">
                            <span style="color: #ffffff; font-weight: 600;">${unansweredCount}</span>
                            <span style="color: #ffffff; font-weight: 400;">unanswered</span>
                        </span>
                    </div>
                `;
            } else {
                document.getElementById('questionCounter').textContent = `${answeredCount} of ${totalQuestions}`;
            }

            document.getElementById('itemNumber').textContent = `Item ${currentQuestion}`;

            // Show/hide explanation button in review mode
            const explanationBtn = document.getElementById('explanationNavBtn');
            if (reviewMode && explanationBtn) {
                const currentQuestionObj = questions.find((q, idx) => (q.question_number || (idx + 1)) === currentQuestion);
                console.log('üîç Looking for question', currentQuestion, 'found:', currentQuestionObj ? 'yes' : 'no', 'has explanation:', currentQuestionObj?.explanation ? 'yes' : 'no');
                if (currentQuestionObj && currentQuestionObj.explanation) {
                    explanationBtn.style.display = 'block';
                    // Reset button text when changing questions
                    const explanationContent = document.getElementById(`explanation-content-${currentQuestion}`);
                    if (explanationContent) {
                        explanationBtn.textContent = explanationContent.style.display === 'none' ? 'Explanation' : 'Hide Explanation';
                    } else {
                        explanationBtn.textContent = 'Explanation';
                    }
                } else {
                    explanationBtn.style.display = 'none';
                }
            }

            // Show/hide question status indicator in review mode
            const statusIndicator = document.getElementById('questionStatusIndicator');
            const statusText = document.getElementById('questionStatusText');
            if (reviewMode && statusIndicator && statusText && reviewModeData) {
                const userAnswerKey = `q${currentQuestion}`;
                const userAnswer = reviewModeData.userAnswers[userAnswerKey];
                const isCorrect = reviewModeData.correctnessMap[userAnswerKey];

                if (!userAnswer) {
                    // Unanswered
                    statusIndicator.style.display = 'flex';
                    statusText.textContent = 'Unanswered';
                } else if (!isCorrect) {
                    // Wrong
                    statusIndicator.style.display = 'flex';
                    statusText.textContent = 'Wrong';
                } else {
                    // Correct - hide indicator
                    statusIndicator.style.display = 'none';
                }
            } else if (statusIndicator) {
                statusIndicator.style.display = 'none';
            }

            updateFlagButton();

            // Typeset math in the currently visible question and passage
            if (window.MathJax) {
                const questionElement = document.getElementById(`question${currentQuestion}`);
                const activePassage = document.querySelector('.passage-content.active');
                const elementsToTypeset = [questionElement, activePassage].filter(el => el);
                if (elementsToTypeset.length > 0) {
                    MathJax.typesetPromise(elementsToTypeset).catch(err => {
                        console.error('MathJax typesetting failed:', err);
                    });
                }
            }
        }

        function nextQuestion() {
            console.log('üîú Next button clicked, current question:', currentQuestion);
            // Find current question index using same logic as rendering
            const currentIdx = questions.findIndex((q, idx) => (q.question_number || (idx + 1)) === currentQuestion);
            console.log('üìç Current index:', currentIdx, 'Total questions:', questions.length);

            if (currentIdx >= 0 && currentIdx < questions.length - 1) {
                const nextQ = questions[currentIdx + 1];
                currentQuestion = nextQ.question_number || (currentIdx + 2);
                console.log('‚û°Ô∏è Moving to question:', currentQuestion);
                sessionStorage.setItem('currentQuestion', currentQuestion);
                updateDisplay();
            } else {
                console.log('‚ö†Ô∏è Cannot go to next question - at end or invalid index');
            }
        }

        function previousQuestion() {
            console.log('üîô Previous button clicked, current question:', currentQuestion);
            // Find current question index using same logic as rendering
            const currentIdx = questions.findIndex((q, idx) => (q.question_number || (idx + 1)) === currentQuestion);
            console.log('üìç Current index:', currentIdx);

            if (currentIdx > 0) {
                const prevQ = questions[currentIdx - 1];
                currentQuestion = prevQ.question_number || currentIdx;
                console.log('‚¨ÖÔ∏è Moving to question:', currentQuestion);
                sessionStorage.setItem('currentQuestion', currentQuestion);
                updateDisplay();
            } else {
                console.log('‚ö†Ô∏è Cannot go to previous question - at beginning or invalid index');
            }
        }

        function goToQuestion(questionNum) {
            console.log('üéØ Going to question:', questionNum);
            // Check if question exists using same logic as rendering
            const questionExists = questions.some((q, idx) => (q.question_number || (idx + 1)) === questionNum);
            if (questionExists) {
                currentQuestion = questionNum;
                sessionStorage.setItem('currentQuestion', currentQuestion);
                updateDisplay();
                closeQuestionModal();
            } else {
                console.log('‚ö†Ô∏è Question', questionNum, 'not found');
            }
        }

        function switchSection(newSection) {
            console.log('üîÑ Switching to section:', newSection);
            if (reviewMode && window.parent) {
                // In review mode, communicate with parent to switch sections
                window.parent.postMessage({
                    type: 'SWITCH_SECTION',
                    section: newSection
                }, '*');
            } else {
                console.log('‚ö†Ô∏è Cannot switch sections - not in review mode or no parent window');
            }
        }

        function toggleFlag() {
            if (flaggedQuestions.has(currentQuestion)) {
                flaggedQuestions.delete(currentQuestion);
            } else {
                flaggedQuestions.add(currentQuestion);
            }
            updateFlagButton();
            updateQuestionGrid();
        }

        function updateFlagButton() {
            const flagBtn = document.getElementById('flagBtn');
            const flagIcon = `<svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none" style="margin-right: 0.25rem;">
                <path d="M4 3C4 2.44772 4.44772 2 5 2C5.55228 2 6 2.44772 6 3V4H15C15.3466 4 15.6684 4.17959 15.8507 4.47427C16.0329 4.76894 16.0494 5.13681 15.8944 5.44721L13.618 10L15.8944 14.5528C16.0494 14.8632 16.0329 15.2311 15.8507 15.5257C15.6684 15.8204 15.3466 16 15 16H6V21C6 21.5523 5.55228 22 5 22C4.44772 22 4 21.5523 4 21V3Z"/>
            </svg>`;

            if (flaggedQuestions.has(currentQuestion)) {
                flagBtn.innerHTML = flagIcon + 'Unflag';
                flagBtn.classList.add('flagged');
            } else {
                flagBtn.innerHTML = flagIcon + 'Flag';
                flagBtn.classList.remove('flagged');
            }
        }

        function showQuestionModal() {
            document.getElementById('questionModal').style.display = 'block';
            generateQuestionGrid();
        }

        function closeQuestionModal() {
            document.getElementById('questionModal').style.display = 'none';
        }

        function generateQuestionGrid() {
            const grid = document.getElementById('questionGrid');
            grid.innerHTML = '';

            // Use actual question numbers from questions array
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1);
                const item = document.createElement('div');
                item.className = 'question-nav-item';
                item.textContent = questionNum;
                item.onclick = () => goToQuestion(questionNum);

                if (questionNum === currentQuestion) {
                    item.classList.add('current');
                } else if (answers[`q${questionNum}`]) {
                    item.classList.add('answered');
                }

                if (flaggedQuestions.has(questionNum)) {
                    item.classList.add('flagged');
                }

                // In review mode, add correct/incorrect styling
                if (reviewMode && reviewModeData) {
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        item.classList.add(isCorrect ? 'review-correct' : 'review-incorrect');
                    } else {
                        item.classList.add('review-unanswered');
                    }
                }

                grid.appendChild(item);
            });
        }
        function generateSidebarQuestions() {
            const sidebar = document.getElementById('sidebarQuestions');
            if (!sidebar) {
                console.log('‚ö†Ô∏è Sidebar element not found, skipping sidebar generation');
                return;
            }

            sidebar.innerHTML = '';

            // Use actual question numbers from questions array
            questions.forEach((q, idx) => {
                const questionNum = q.question_number || (idx + 1);
                const item = document.createElement('div');
                item.className = 'sidebar-question-item';
                item.textContent = questionNum;
                item.onclick = () => goToQuestion(questionNum);

                if (questionNum === currentQuestion) {
                    item.classList.add('current');
                } else if (answers[`q${questionNum}`]) {
                    item.classList.add('answered');
                } else if (flaggedQuestions.has(questionNum)) {
                    item.classList.add('flagged');
                }

                // In review mode, add correct/incorrect styling
                if (reviewMode && reviewModeData) {
                    const userAnswerKey = `q${questionNum}`;
                    const isCorrect = reviewModeData.correctnessMap[userAnswerKey];
                    const userAnswer = reviewModeData.userAnswers[userAnswerKey];

                    if (userAnswer) {
                        item.classList.add(isCorrect ? 'review-correct' : 'review-incorrect');
                    } else {
                        item.classList.add('review-unanswered');
                    }
                }

                sidebar.appendChild(item);
            });
        }

        function toggleSidebar() {
            // Sidebar is always visible now, this could be used for future expand/collapse
            showQuestionModal();
        }

        function updateQuestionGrid() {
            generateSidebarQuestions();
            if (document.getElementById('questionModal').style.display === 'block') {
                generateQuestionGrid();
            }
        }

        function startTimer() {
            const timerElement = document.getElementById('timer');
            if (!timerElement) {
                console.error('Timer element not found!');
                return;
            }

            console.log('‚è∞ Starting timer with duration:', duration, 'minutes');

            // Set initial display immediately
            const initialMinutes = Math.floor(timeLeft / 60);
            const initialSeconds = timeLeft % 60;
            timerElement.textContent = `${initialMinutes}:${initialSeconds.toString().padStart(2, '0')}`;

            // Update every second
            setInterval(() => {
                if (timeLeft > 0) {
                    timeLeft--;
                    const minutes = Math.floor(timeLeft / 60);
                    const seconds = timeLeft % 60;
                    timerElement.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

                    // Red color when under 5 minutes
                    if (timeLeft <= 300) {
                        timerElement.style.color = '#dc2626';
                    }
                } else if (timeLeft === 0) {
                    timerElement.textContent = '0:00';
                    console.log('Time is up!');
                }
            }, 1000);
        }

        function confirmEndSection() {
            console.log('üî¥ confirmEndSection called');
            const unanswered = totalQuestions - Object.keys(answers).length;
            const warning = document.getElementById('unansweredWarning');

            console.log('üìä Stats:', { totalQuestions, answeredCount: Object.keys(answers).length, unanswered });

            if (unanswered > 0) {
                warning.textContent = `You have ${unanswered} unanswered question${unanswered > 1 ? 's' : ''}.`;
            } else {
                warning.textContent = '';
            }

            const modal = document.getElementById('confirmModal');
            console.log('üì¶ Modal element:', modal);
            modal.style.display = 'block';
            console.log('‚úÖ Modal should now be visible');
        }

        function closeConfirmModal() {
            document.getElementById('confirmModal').style.display = 'none';
        }

        function endSection() {
            console.log('üü¢ endSection called');

            // IMPORTANT: Re-read section from sessionStorage to get current value
            // The section variable at top of script is stale when sections change
            const currentSection = sessionStorage.getItem('practiceTestSection') || section;

            console.log('üîç Section values:', {
                oldSectionVariable: section,
                sessionStorageSection: sessionStorage.getItem('practiceTestSection'),
                usingSection: currentSection
            });

            closeConfirmModal();

            // Calculate score for current section
            let correct = 0;
            questions.forEach((q, idx) => {
                const questionNum = idx + 1;
                const userAnswer = answers[`q${questionNum}`];
                if (userAnswer === q.correctAnswer) {
                    correct++;
                }
            });

            const percentage = Math.round((correct / totalQuestions) * 100);

            console.log('üìà Score calculated:', { correct, total: totalQuestions, percentage });

            // Store current section results
            const currentResults = {
                section: currentSection,
                correct,
                total: totalQuestions,
                percentage,
                answers,
                flagged: Array.from(flaggedQuestions),
                questions: questions.map((q, idx) => ({
                    questionId: q.id, // Database ID for answer saves
                    questionNum: q.question_number, // Actual question number from database
                    section: currentSection, // Section for each question
                    selectedAnswer: answers[`q${idx + 1}`] ?? null, // User's answer (null if unanswered so it survives JSON.stringify)
                    correctAnswer: q.correctAnswer,
                    isCorrect: answers[`q${idx + 1}`] === q.correctAnswer,
                    timeSpent: 0 // TODO: Add time tracking
                }))
            };

            // Debug: Log first question to verify structure
            if (currentResults.questions.length > 0) {
                console.log('üîç First question structure:', {
                    fields: Object.keys(currentResults.questions[0]),
                    sample: currentResults.questions[0]
                });
            }

            // Get all previous results
            const allResults = JSON.parse(sessionStorage.getItem('practiceTestAllResults') || '[]');
            allResults.push(currentResults);
            sessionStorage.setItem('practiceTestAllResults', JSON.stringify(allResults));

            console.log('üìö All completed sections:', allResults.map(r => r.section));

            // Check if all 4 sections have been completed
            const sectionOrder = ['english', 'math', 'reading', 'science'];
            const completedSections = new Set(allResults.map(r => r.section.toLowerCase().trim()));
            const allSectionsComplete = sectionOrder.every(s => completedSections.has(s));

            console.log('üîç Completion check:', {
                completedSections: Array.from(completedSections),
                allSectionsComplete,
                requiredSections: sectionOrder
            });

            const normalizedSection = currentSection.toLowerCase().trim();
            const currentIndex = sectionOrder.indexOf(normalizedSection);

            console.log('üéØ Section ended:', {
                section: currentSection,
                normalizedSection,
                currentIndex,
                allSectionsComplete,
                willComplete: allSectionsComplete
            });

            // Check if all 4 sections are complete
            if (allSectionsComplete) {
                // Test complete - all 4 sections done
                console.log('üì§ Sending COMPLETE message - All 4 sections finished');
                console.log('   Completed sections:', Array.from(completedSections));

                // Keep only the LAST result for each section (in case sections were redone)
                const uniqueResults = [];
                sectionOrder.forEach(sectionName => {
                    // Find the last result for this section
                    for (let i = allResults.length - 1; i >= 0; i--) {
                        if (allResults[i].section.toLowerCase().trim() === sectionName) {
                            uniqueResults.push(allResults[i]);
                            break;
                        }
                    }
                });

                console.log('üìä Final results (last attempt per section):', uniqueResults.map(r => r.section));

                sessionStorage.setItem('practiceTestResults', JSON.stringify({
                    allSections: uniqueResults,
                    totalCorrect: uniqueResults.reduce((sum, r) => sum + r.correct, 0),
                    totalQuestions: uniqueResults.reduce((sum, r) => sum + r.total, 0)
                }));

                const completeMessage = { type: 'PRACTICE_TEST_COMPLETE' };
                console.log('üì§ Posting COMPLETE message to parent:', completeMessage);
                window.parent.postMessage(completeMessage, '*');
                console.log('‚úÖ Complete message posted to parent');
            } else if (currentIndex >= 0 && currentIndex < sectionOrder.length - 1) {
                // Load next section
                const nextSection = sectionOrder[currentIndex + 1];
                console.log('üì§ Sending NEXT_SECTION message:', nextSection);
                const message = {
                    type: 'PRACTICE_TEST_NEXT_SECTION',
                    nextSection: nextSection,
                    currentResults: currentResults
                };
                console.log('üì¶ Full message object:', message);
                window.parent.postMessage(message, '*');
                console.log('‚úÖ Message posted to parent');
            } else {
                // Edge case: current section is last but not all sections complete
                console.log('‚ö†Ô∏è Edge case: Last section but not all complete, sending COMPLETE anyway');

                // Keep only the LAST result for each section
                const uniqueResults = [];
                sectionOrder.forEach(sectionName => {
                    for (let i = allResults.length - 1; i >= 0; i--) {
                        if (allResults[i].section.toLowerCase().trim() === sectionName) {
                            uniqueResults.push(allResults[i]);
                            break;
                        }
                    }
                });

                sessionStorage.setItem('practiceTestResults', JSON.stringify({
                    allSections: uniqueResults,
                    totalCorrect: uniqueResults.reduce((sum, r) => sum + r.correct, 0),
                    totalQuestions: uniqueResults.reduce((sum, r) => sum + r.total, 0)
                }));

                const completeMessage = { type: 'PRACTICE_TEST_COMPLETE' };
                window.parent.postMessage(completeMessage, '*');
            }
        }

        // Sliding Navigator Panel Functions
        function toggleNavigator() {
            const panel = document.getElementById('navigatorPanel');
            const testMain = document.querySelector('.test-main');
            const sidebar = document.querySelector('.question-sidebar');
            const isOpen = panel.classList.contains('open');

            if (isOpen) {
                panel.classList.remove('open');
                testMain.classList.remove('navigator-open');
                sidebar.classList.remove('navigator-open');
            } else {
                panel.classList.add('open');
                testMain.classList.add('navigator-open');
                sidebar.classList.add('navigator-open');
                populateNavigator();
            }
        }

        function populateNavigator() {
            console.log('üîç populateNavigator called');
            const navigatorContent = document.getElementById('navigatorContent');
            if (!navigatorContent) {
                console.error('Navigator content element not found');
                return;
            }

            navigatorContent.innerHTML = '';
            console.log('‚úÖ Found navigatorContent, cleared it');

            if (!questions || questions.length === 0) {
                console.error('‚ùå No questions to populate');
                navigatorContent.innerHTML = '<div style="padding: 1rem; text-align: center; color: #1a1a1a; font-weight: 600;">No questions loaded</div>';
                return;
            }

            console.log(`üìù Populating ${questions.length} questions`);
            console.log('Review mode:', reviewMode);
            console.log('Review mode data:', reviewModeData);

            // Stats header removed for cleaner design
            console.log('‚úÖ Starting question population');

            let itemsCreated = 0;
            let errorCount = 0;

            questions.forEach((q, idx) => {
                try {
                    const questionNum = idx + 1;

                    // Check if in review mode
                    const userAnswerKey = `q${questionNum}`;
                    const userAnswer = reviewMode && reviewModeData ? reviewModeData.userAnswers[userAnswerKey] : null;
                    const correctAnswer = q.correctAnswer;
                    const isCorrect = reviewMode && userAnswer === correctAnswer;
                    const isIncorrect = reviewMode && userAnswer && userAnswer !== correctAnswer;
                    const isSkipped = reviewMode && !userAnswer;
                    const isCurrent = questionNum === currentQuestion;
                    const isAnswered = answers[`q${questionNum}`];
                    const isFlagged = flaggedQuestions.has(questionNum);

                    const item = document.createElement('div');
                    item.className = 'navigator-question-item';
                    if (isCurrent) item.classList.add('current');
                    if (!reviewMode && isAnswered) item.classList.add('answered');
                    if (isFlagged) item.classList.add('flagged');

                    // Add review mode classes
                    if (reviewMode) {
                        if (isCorrect) item.classList.add('review-correct');
                        else if (isIncorrect) item.classList.add('review-incorrect');
                        else if (isSkipped) item.classList.add('review-skipped');
                    }

                    // Extract question preview - handle all question types
                    let questionPreview = 'Question ' + questionNum;

                    try {
                        // For questions with passages (English, Reading, Science)
                        if (q.passage) {
                            // Find ALL underlined portions in the passage
                            const underlineMatches = q.passage.match(/<u[^>]*>(.*?)<\/u>/gi);
                            if (underlineMatches && underlineMatches.length > 0) {
                                // Try to match this question to its underlined portion
                                let targetUnderline = null;

                                // First, try to find which underline corresponds to this question
                                // by looking for the question number in the passage structure
                                const passageQuestionNumbers = [];
                                let passageText = q.passage;

                                // Count questions in this passage to find relative position
                                questions.forEach((otherQ, otherIdx) => {
                                    if (otherQ.passage === q.passage) {
                                        passageQuestionNumbers.push(otherIdx);
                                    }
                                });

                                // Find this question's position within its passage
                                const positionInPassage = passageQuestionNumbers.indexOf(idx);

                                if (positionInPassage >= 0 && underlineMatches[positionInPassage]) {
                                    targetUnderline = underlineMatches[positionInPassage];
                                }

                                if (targetUnderline) {
                                    let underlinedText = targetUnderline.replace(/<[^>]+>/g, '').replace(/<\/?u[^>]*>/gi, '').trim();

                                    if (underlinedText.length > 0) {
                                        if (underlinedText.length > 50) {
                                            questionPreview = `...<u style="text-decoration: underline;">${underlinedText.substring(0, 47)}...</u>`;
                                        } else {
                                            questionPreview = `...<u style="text-decoration: underline;">${underlinedText}</u>...`;
                                        }
                                    }
                                }
                            }

                            // If still no preview, try to get question text from reading/science questions
                            if (questionPreview === 'Question ' + questionNum && q.text) {
                                const plainText = q.text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                                const withoutBrackets = plainText.replace(/\[.*?\]|\(.*?\)/g, '').trim();
                                if (withoutBrackets.length > 10) {
                                    questionPreview = withoutBrackets.substring(0, 50) + (withoutBrackets.length > 50 ? '...' : '');
                                }
                            }
                        } else if (q.text) {
                            // For non-passage questions (Math primarily)
                            const plainText = q.text.replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
                            const withoutBrackets = plainText.replace(/\[.*?\]|\(.*?\)/g, '').trim();
                            if (withoutBrackets.length > 10) {
                                questionPreview = withoutBrackets.substring(0, 50) + (withoutBrackets.length > 50 ? '...' : '');
                            }
                        }
                    } catch (e) {
                        console.error('Error extracting preview for Q' + questionNum, e);
                        questionPreview = 'Question ' + questionNum;
                    }

                    // Status indicator for review mode
                    let statusIndicator = '';
                    if (reviewMode) {
                        if (isCorrect) {
                            statusIndicator = '<div style="width: 20px; height: 20px; border-radius: 50%; background: #dcfce7; border: 2px solid #86efac; display: flex; align-items: center; justify-content: center; color: #10b981; font-size: 0.75rem; font-weight: 600;">‚úì</div>';
                        } else if (isIncorrect) {
                            statusIndicator = '<div style="width: 20px; height: 20px; border-radius: 50%; background: #fee2e2; border: 2px solid #fecaca; display: flex; align-items: center; justify-content: center; color: #ef4444; font-size: 0.75rem; font-weight: 600;">‚úó</div>';
                        }
                    }

                    item.innerHTML = `
                        <div class="navigator-question-header">
                            <div style="display: flex; align-items: center; gap: 0.5rem;">
                                <span class="navigator-question-number">Q${questionNum}</span>
                                ${statusIndicator}
                            </div>
                            <div class="navigator-question-status">
                                ${!reviewMode && isAnswered ? '<span class="navigator-status-badge answered">‚úì</span>' : ''}
                                ${isFlagged ? '<span class="navigator-status-badge flagged">‚öë</span>' : ''}
                            </div>
                        </div>
                        <div class="navigator-question-preview">${questionPreview}</div>
                    `;

                    item.onclick = () => {
                        currentQuestion = questionNum;
                        sessionStorage.setItem('currentQuestion', currentQuestion);
                        updateDisplay();
                        toggleNavigator();
                    };

                    navigatorContent.appendChild(item);
                    itemsCreated++;
                } catch (error) {
                    console.error(`‚ùå Error creating navigator item ${idx + 1}:`, error);
                    errorCount++;
                }
            });

            console.log(`‚úÖ Created and appended ${itemsCreated} question items`);
            if (errorCount > 0) {
                console.error(`‚ùå ${errorCount} errors occurred while creating items`);
            }
            console.log('Navigator content children:', navigatorContent.children.length);

            // Debug: Show first few items
            if (navigatorContent.children.length > 1) {
                console.log('Sample item HTML:', navigatorContent.children[1].outerHTML.substring(0, 200));
            }

            // Scroll to current question
            setTimeout(() => {
                const currentItem = navigatorContent.querySelector('.navigator-question-item.current');
                if (currentItem) {
                    currentItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const questionModal = document.getElementById('questionModal');
            const confirmModal = document.getElementById('confirmModal');

            if (event.target === questionModal) {
                closeQuestionModal();
            }
            if (event.target === confirmModal) {
                closeConfirmModal();
            }
        };

        // Prevent accidental page close
        window.addEventListener('beforeunload', function (e) {
            if (Object.keys(answers).length > 0) {
                e.preventDefault();
                e.returnValue = '';
            }
        });

        // Initialize when page loads
        window.addEventListener('load', () => {
            initTest();
        });
    </script>
</body>
</html>
